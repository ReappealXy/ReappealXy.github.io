<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Spring AI-参考-聊天客户端API | XyreOS</title><meta name="keywords" content="Spring AI-参考-聊天客户端API"><meta name="author" content="Xyre,reappealxy@gmail.com"><meta name="copyright" content="Xyre"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Spring AI-参考-聊天客户端API"><meta name="application-name" content="Spring AI-参考-聊天客户端API"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Spring AI-参考-聊天客户端API"><meta property="og:url" content="https://xyre.online/2025/06/16/Spring%20AI/Spring-AI-%E5%8F%82%E8%80%83-%E8%81%8A%E5%A4%A9%E5%AE%A2%E6%88%B7%E7%AB%AFAPI/index.html"><meta property="og:site_name" content="XyreOS"><meta property="og:description" content="Spring AI-参考-聊天客户端API"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://xyre.online/img/avatar.png"><meta property="article:author" content="Xyre"><meta property="article:tag" content="个人博客"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://xyre.online/img/avatar.png"><meta name="description" content="Spring AI-参考-聊天客户端API"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://xyre.online/2025/06/16/Spring%20AI/Spring-AI-%E5%8F%82%E8%80%83-%E8%81%8A%E5%A4%A9%E5%AE%A2%E6%88%B7%E7%AB%AFAPI/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'your-env-id',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":null},
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["💻 Java 开发者","🔍 喜欢研究技术细节","🎨 前端爱好者","🚀 目标：成为全栈工程师"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Xyre","link":"链接: ","source":"来源: XyreOS","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'XyreOS',
  title: 'Spring AI-参考-聊天客户端API',
  postAI: '',
  pageFillDescription: '聊天客户端API, 创建ChatClient, 使用自动配置的 ChatClient.Builder, 使用多个聊天模型, 针对单一模型类型的多个 ChatClient, 多个兼容 OpenAI 的 API 端点, ChatClient 流式 API, ChatClient 响应 (ChatClient Responses), 返回一个 ChatResponse, 返回一个实体 (Entity), 流式响应 (Streaming Responses), 提示模板 (Prompt Templates), .call() 的返回值(call() return values), .stream() 的返回值(stream() return values), Using Defaults(使用默认值), 默认系统文本 (Default System Text), 带参数的默认系统文本 (Default System Text with parameters), 其他默认值 (Other defaults)聊天客户端提供了一个流式用于与模型进行通信它同时支持同步和流式两种编程模型请参阅本文档底部的实现说明其中涉及在中结合使用命令式和响应式编程模型的相关内容这个流式提供了一些方法用于构建一个的各个组成部分这个将作为输入传递给模型中包含了指导性文本用以引导模型的输出和行为从的角度来看提示是由一系列消息组成的模型主要处理两种类型的消息用户消息即来自用户的直接输入以及系统消息由系统生成用以引导对话这些消息通常包含占位符这些占位符会在运行时根据用户输入被替换从而根据用户输入定制化模型的响应此外还可以指定一些提示选项例如要使用的模型的名称以及用于控制生成输出的随机性或创造力的温度设置核心组件这个组件是用来和模型例如的聊天的接口两大编程模型同步流式同步你问一个问题然后一直等着直到把完整的答案一次性全部给你这就像下载一个文件必须等它下载完才能打开流式你问一个问题一边思考一边回答把答案一个词一个词地吐给你这就像看在线视频视频内容是流式传输过来的你不用等整个视频下载完就能开始看网站的打字机效果就是典型的流式响应核心交互方式流式也常被称为链式调用它的特点是你可以像链条一样把多个方法调用串在一起让代码读起来像自然语言一样流畅以下写一个伪代码来方便理解你是一个专业的诗人先设置系统角色写一首关于春天的五言绝句再提供用户问题发起调用获取结果核心输入结构和提示可以理解为你要发送给的整个请求包裹消息是这个包裹里的具体内容可以有多条一个对象里通常会包含一个或多个对象两种主要消息类型这是的核心概念用户消息就是你用户对说的话比如帮我翻译一下这句话写一段代码系统消息这是你给设定的人设或行为准则它在对话开始前告诉你接下来要扮演一个什么样的角色遵守什么样的规则比如你是一个从不讲笑话的严肃历史学家你的所有回答都必须使用中文并且格式为动态化占位符你可以在消息文本里预留一些坑占位符比如在实际调用时再把替换成具体的值比如或者这让你的提示可以被复用精细控制提示选项除了对话内容你还可以设置一些超参数来微调的行为模型名称指定你要用哪个模型比如还是温度这是一个非常重要的参数控制回答的创造性或随机性低温比如的回答会非常确定严谨重复性高适合需要事实和精确答案的场景高温比如的回答会更有创意更天马行空更多样化适合头脑风暴写故事等场景创建是使用对象创建的您可以为任何自动配置获取自动配置的实例或者以编程方式创建一个实例使用自动配置的在最简单的用例中提供自动配置创建一个原型供你注入到你的类中下面是检索对简单用户请求的响应的简单示例在这个简单的示例中用户输入设置用户消息的内容方法向模型发送请求方法将模型的响应作为返回我现在来详细注释一下这个代码是一个组合注解它结合了和告诉这一个类是模式中的控制器负责处理请求告诉这个类中所有方法的返回值都应该直接作为响应体的内容返回通常是或像本例中的纯文本而不是去查找一个视图如或模板关键字声明是一个最终变量这意味着它必须在对象构造时被初始化且之后不能再被修改这是一种推荐的编程实践可以增强代码的健壮性和线程安全性这是一个构造函数框架会用它来创建的实例这也是推荐的依赖注入方式构造函数注入参数当创建时它会自动在自己的容器中寻找一个类型的并把它作为参数传进来这个是由的自动配置功能提前为我们准备好的已经包含了所有必要的配置如这个是可有可无的注释因为从版本开始如果一个类只有一个构造函数那么就会自动使用这个构造函数来进行依赖注入此时注解是可选的可以省略使用注入的对象通过调用方法来创建一个最终可用配置完备的实例这个调用标志着配置阶段的结束和可用对象的诞生将这个方法映射到请求的路径当用户访问时这个方法就会被触发处理请求获取数据处理请求新建数据处理请求更新数据处理请求删除数据处理请求部分更新数据是最基础的请求映射注解它可以用来处理任何类型的请求这行代码只处理请求就完全等同于我们之前学的只处理请求会自动将中的查询参数如的值赋给同名的方法参数例如访问则的值就是这是整个案例最核心的一行体现了的链式设计获取我们已经创建好的实例调用方法这表示我要开始构建一个新的请求了它返回一个可以继续配置请求的中间对象在这个新的请求中添加一条用户消息消息的内容就是从参数中获取的字符串这是在告诉这是用户对你提出的问题或指令这是触发器表示我的请求已经构建完毕现在请把它发送给模型这是一个同步阻塞调用意味着程序会在这里暂停一直等到模型处理完请求并返回完整的响应后代码才会继续往下执行方法返回的是一个包含所有响应信息的对象比如方法则是从这个响应对象中提取出我们最关心的核心部分生成的文本内容这个方法最终返回一个使用多个聊天模型在以下几种情况下您可能需要在单个应用程序中使用多个聊天模型对不同类型的任务使用不同的模型例如用于复杂推理的强大模型和用于简单任务的更快更便宜的模型当一个模型服务不可用时实现回退机制测试不同的型号或配置为用户提供基于其偏好的模型选择组合专用模型一个用于代码生成另一个用于创意内容等默认情况下会自动配置单个但是您可能需要在应用程序中使用多个聊天模型以下是处理此情况的方法在所有情况下您都需要通过设置属性来禁用自动配置这允许您手动创建多个实例解读当默认的一个应用对应一个模型的简单模式不够用时提供了灵活的手动配置方式来支持更复杂的多模型场景为什么要用多个模型原文列举了几个非常经典的理由成本与性能的权衡场景做一个智能客服对于简单的问候查询订单等任务用一个便宜快速的模型如就够了但如果用户提出复杂的投诉或需要深度分析的问题就切换到更强大但更贵的模型如核心思想好钢用在刀刃上不同任务用不同工具高可用性与容错场景你的主要服务商比如突然宕机了为了不影响用户系统可以自动切换到备用的服务商比如的或的核心思想不要把所有鸡蛋放在一个篮子里实验与优化场景你不确定用模型还是模型的效果更好你可以让的用户流量走模型另外走模型然后比较哪个的用户满意度更高或业务指标更好核心思想用数据说话找到最优解用户自定义场景在你的应用里像一个设置选项一样让用户自己选择喜欢用聪明但慢一点的还是快一点但可能没那么聪明的核心思想把选择权交给用户专业分工场景你的应用既能帮你写代码又能帮你写诗你可以配置一个专门为代码优化过的模型如来处理代码生成请求同时用另一个擅长创意的模型如来写诗核心思想让专业的人做专业的事如何实现理解了为什么之后怎么做就成了关键的解决方案非常直接第一步关闭默认的傻瓜模式默认行为默认会自动配置好一个让用户开箱即用这很方便但也限制了用户只能有一个默认的客户端需要做的在或文件里加上这行配置它的作用这行配置等于告诉谢谢你的好意但别再帮我自动创建那个默认的了接下来的事情我自己来第二步自己动手丰衣足食一旦关闭了自动配置你就获得了完全的自由你现在可以像创建任何普通的一样在你的配置类中手动创建任意多个实例每个实例都可以绑定到不同的底层比如一个连一个连或者绑定到同一个但使用不同的默认设置比如一个高温一个低温总结这段内容是从入门到进阶的一个重要转折点入门模式依赖自动配置快速搞定单个模型的集成进阶模式自动配置手动创建和配置多个以满足复杂的业务需求针对单一模型类型的多个本节介绍一个常见的用例即您需要创建多个实例这些实例都使用相同的底层模型类型但具有不同的配置以编程方式创建实例由自动配置一个代表大模型的连接器例如连接的然后我们创建一个供开发者使用的更友好的客户端并将那个连接器作为它的底层引擎这样我们就可以通过的简洁来间接操作发起请求了它的用处就是帮你封装了一套默认的重复的请求配置让你在后续调用时可以写出更简洁更专注于业务变化的代码已由自动配置或者使用来获得更多控制你是一个乐于助人的助手第一种方法核心目的快速直接地创建一个基础的实例不包含任何预设的默认配置实现方式通过接口的静态工厂方法最终产物一个标准版或裸版的它是一个功能完备的客户端但没有任何个性化设置适用场景当你的请求每次都完全不同或者你倾向于在每次调用时都明确指定所有参数如系统提示模型选项等不希望有任何隐藏的默认行为时第二种方法核心目的创建一个带有预设默认配置例如默认系统提示默认模型参数等的可复用的实例实现方式采用建造者设计模式启动构建过程返回一个对象在上进行链式调用以声明所需的默认配置完成构建生成最终的实例最终产物一个定制版或智能版的这个实例内部封装了你在构建时设定的默认值适用场景当你有一类相似的请求例如所有的客服对话所有的代码翻译任务它们总是需要共享相同的背景指令或参数时使用这种方式可以极大地简化后续的调用代码避免重复设置用于不同模型类型的当使用多个模型时您可以为每个模型定义单独的然后您可以使用注解将这些注入到您的应用程序组件中第一个工具指名道姓要这个第二个工具指名道姓要这个模型选择选择您的模型输入您的选择或去掉前后的空格正在使用模型正在使用模型使用选定的聊天客户端输入您的问题助手一句话总结它是一个消除歧义的注解在有多个同类型的情况下通过指定的名字来精确地注入你想要的那一个来讲解一下这个步骤第一步例如我想问今天的天气如何这个词在领域它的标准翻译是提示或提示语它不仅仅是关键词而是你希望对其作出回应的完整指令或上下文这段代码其实是一个语法糖它等价于动作是准备一封新信件创建一个新的请求对象动作是在这封信的用户提问区写上的内容所以当你写今天的天气如何时你实际上是在创建一个请求这个请求里包含了一条用户消息内容就是今天的天气如何第二步的意思是调用或执行它是整个流程的发送按钮它的作用告诉我的信已经准备好了现在请你把它发送给模型然后在原地等待直到你收到完整的回信它的性质这是一个同步阻塞的操作同步意味着它会一次性返回完整的结果而不是一点一点地返回阻塞意味着你的程序代码在执行到时会暂停就像卡住了一样直到网络另一头的模型把所有文字都生成完毕并将结果传回你的程序你的代码才会继续往下走它的返回值执行完毕后返回的不是一个简单的字符串而是一个包含了所有响应信息的包裹这个包裹的类型是这个包裹里除了有回答的文本内容可能还有其他信息比如这次调用消耗了多少调用是否成功决定停止回答的原因等等第三步的意思是内容它是整个流程的拆信封动作它的作用从上一步返回的那个响应包裹中提取出我们最关心的核心部分生成的文本内容它的性质这是一个简单的数据提取操作它的返回值方法最终返回一个我们最熟悉的对象这个字符串就是对你问题的回答比如很抱歉我无法获取实时的天气信息多个兼容的端点和类提供了一个方法它允许您创建现有实例的具有不同属性的变体当您需要与多个兼容的协同工作时这个功能特别有用为派生一个新的为派生一个新的为派生一个新的为派生一个新的为两个模型准备一个简单的提示法国的首都是哪里的回答的回答在多客户端流程中出错这段代码解决了一个非常有趣的问题现在市面上有很多新兴的服务比如等它们为了方便开发者迁移都提供了兼容规范的接口这意味着你可以用和调用完全相同的代码结构去调用它们只需要更换地址和密钥即可这段代码的核心就是展示如何利用的方法优雅地实现这种动态切换核心概念方法的意思是变异或派生它是一种以我为模板创建一个稍作修改的新副本的设计模式类似于原型模式当你调用时它会返回一个对象这个的初始状态完全继承了的所有属性然后你可以对这个进行局部修改最后调用来生成一个全新的修改后的实例而原始的保持不变流式流式允许您通过一个重载的方法以三种不同的方式来创建一个提示从而启动流式的调用链这个无参数的方法让您可以开始使用流式允许您逐步构建用户消息系统消息以及提示的其他部分完全自定义点餐代码比喻你走到点餐台前对服务员说我要开始点餐了然后你开始一步步地告诉他我要一个汉堡不要酸黄瓜加双份芝士各种再来一杯可乐另一个或工具调用对了记得提醒厨师我是你们的超级会员口味要重一点使用场景这是最灵活最常用的方式你需要从零开始构建一个复杂的请求包含系统消息用户消息各种选项等链式调用的所有功能都可以从这个起点开始起点你是一个专业的翻译家请把翻译成法语这个方法接受一个对象作为参数让您可以传入一个已经通过类的非流式创建好的实例拿着写好的菜单直接点餐代码比喻你在来餐厅的路上就已经用提前把你的菜单一个对象编辑好了到了餐厅你直接把手机上的菜单二维码给服务员一扫说就照这个单子做使用场景当你因为某些原因比如代码解耦从其他模块传来等已经有了一个构建好的完整的对象时用这个方法可以最直接地把它交给在别的地方你已经费心构建好了一个对象现在直接把它扔给起点这是一个类似于上一个重载方法的便捷方法它直接接受用户的文本内容代码你好吗比喻你赶时间直接对服务员喊来一份最简单的单人套餐这里的套餐内容就是你提供的那段字符串使用场景这是最简单最便捷的方式专门用于那种只有一个用户问题没有其他任何要求的场景它在内部会自动帮你把这个字符串包装成一个只包含单条用户消息的对象背后相当于你好吗你好吗起点响应通过其流式提供了多种方式来格式化来自模型的响应解读当用户调用模型后通过或不仅仅是给用户一个简单的字符串它提供了一套丰富的工具让用户能以不同的形式提取和转换的响应结果返回一个来自模型的响应是一个由类型定义的丰富结构它包含了关于响应是如何生成的元数据并且还可以包含多个被称为的响应结果每个结果都有其自己的元数据这些元数据包含了用于创建响应的令牌数量每个大约相当于个单词这个信息很重要因为托管的模型是根据每次请求使用的数量来收费的下面展示了一个示例通过在方法后调用来返回包含元数据的对象解读的响应远不止一串文本那么简单它是一个包含丰富附加信息的复杂对象而方法就是获取这个完整对象的钥匙方法返回类型用途比喻只想要核心文本内容简单快捷只看电影正片想要全部包括元数据消耗等看蓝光典藏版影碟返回一个实体您通常希望返回一个从返回的字符串映射而来的实体类方法提供了此功能例如给定以下您可以使用方法轻松地将模型的输出映射到这个如下所示生成一个随机演员的电影作品列表此外还有一个重载的方法其签名为它允许您指定泛型类型例如泛型列表生成汤姆汉克斯和比尔默瑞的电影作品列表解读核心就是不要再手动解析返回的字符串了可以自动帮你把的文本回答直接转换成你想要的对象比喻手动翻译同声传译传统方式手动解析你告诉请用格式返回演员汤姆汉克斯的电影列表返回给你一长串文本你拿到这个字符串后需要自己找一个解析库比如或写一堆代码来把它手动转换成你的对象这就像你听到一段外语需要先用笔把它逐字记下来然后再查字典一个词一个词地翻译过程繁琐且容易出错的方式结构化输出你用同样的方式告诉你想要什么然后你直接在调用链的末尾加上在背后默默地帮你完成了所有工作它会优化你的确保更大概率返回正确的格式它拿到返回的文本它自动调用内置的解析器将文本转换成你指定的实例你直接就得到了一个类型安全立即可用的对象这就像你戴上了一副同声传译耳机你听到外语的同时耳机里已经传来了翻译好的母语过程无缝高效无需动手两种方法的用法用于简单的非泛型的对象代码何时使用当你期望的结果是一个单一的具体的类的实例时比如示例定义一个简单的对象用更简洁发起调用并直接获取对象为随机一位演员生成电影作品列表直接指定类现在可以直接使用对象了演员用于复杂的带泛型的对象代码为何需要这么复杂因为的泛型有类型擦除的特性在运行时和都会被擦除成同一个只传入程序就不知道列表里面应该装什么类型的对象是提供的一种技巧它能在运行时保留并传递完整的泛型信息我想要的不仅是个而是个装满了的何时使用当你期望的结果是一个泛型集合时最常见的就是等示例目标是获取一个对象的列表为汤姆汉克斯和比尔默里各生成部电影的作品列表保留泛型信息现在可以直接遍历这个列表了演员方法用途关键点将响应映射到单个普通对象简单直接适用于非泛型类将响应映射到泛型集合如解决了泛型擦除问题必须用这种写法是的杀手级功能之一它将大语言模型的非结构化文本输出与的强类型结构化编程世界无缝地连接了起来是构建健壮可靠应用的基石流式响应方法让您能够获得一个异步的响应如下所示您也可以使用方法来流式地获取未来我们将提供一个便捷的方法让您可以通过响应式的方法直接返回一个实体在此期间您应该使用结构化输出转换器来显式地转换聚合后的响应如下所示这也演示了在流式中使用参数的方法这将在文档的后续部分进行更详细的讨论创建一个指定期望的输出类型发起流式请求收集所有流式返回的字符串片段并合并成一个完整的字符串使用转换器手动将完整的字符串内容转换为对象列表解读这段话的核心是告诉你如何处理像网站上那种一个词一个词往外蹦的响应效果并点出了当前在流式场景下获取结构化数据对象的临时解决方案什么是流式响应同步你问问题然后一直等直到把完整的一大段话说完你才收到所有内容流式异步你问问题一边想一边说它每想出一个词或一小段话就立刻发给你你收到的是一个持续不断的数据流而不是一次性的完整结果返回类型方法返回的是一个对象是的响应式编程库中的一个核心类型代表一个可以发出到个元素的异步序列数据流简单的流式文本关键从这里开始一切都是异步的流式的从流中的每个小块里提取文本内容工作流程发起请求但不会阻塞而是立即返回一个模型开始生成响应比如会依次发出这些字符串片段你可以订阅这个来处理每一个到来的片段例如在界面上实时显示它们实现打字机效果流式场景下的结构化输出一个当前的权宜之计这是本段最复杂也最重要的部分问题所在这个便捷的方法在模式下尚不可用原文说未来会提供你不能直接因为流是一个个碎片你无法在收到第一个碎片时就把它转换成一个完整的对象当前的解决方案分三步走准备工作创建转换器并修改手动创建一个转换器告诉它你最终想要什么类型的对象比如最关键的一步这个转换器内部有一个方法它能生成一段特殊的指令文本告诉请务必以我指定的格式返回你的答案你必须把这个指令作为参数塞进你的里执行与收集发起流式请求并把所有碎片重新拼起来像之前一样获取一个包含字符串碎片的这是一个响应式编程的操作把流里的所有碎片都收集起来放到一个列表里一直等直到所有碎片都收集完毕这里把异步操作又变回了同步等待因为你需要完整的才能解析把列表里的所有字符串碎片无缝拼接成一个完整的字符串手动转换使用转换器完成最后一步现在你有了完整的字符串最后调用转换器的方法手动完成从字符串到对象的转换场景方法链解释获取流式文本简单直接获取用于实现打字机效果获取流式结构化对象当前复杂三步法创建并修改后收集并拼接成完整字符串手动调用虽然的目标是让一切都简单但在某些功能如流式结构化输出尚未完全成熟时它也为你提供了底层的稍微复杂一些的手动工具作为过渡方案提示模板前情提要什么是提示模板为什么需要它没有模板硬编码如果你想问关于狗的笑话你得重写整个字符串使用模板这是一个可复用的模板你可以保持模板不变只在运行时改变的值比如就能生成不同的提示流式允许您将用户和系统的文本作为带有变量的模板来提供这些变量会在运行时被替换这段话的核心是告诉你不要把你的提示写死内置了一个强大的模板引擎让你可以在提示中预留坑位占位符然后在运行时动态地填入内容在方法中用占位符的形式定义你的模板使用方法为同名的占位符提供具体的值定义模板字符串为模板中名为的占位符填充在发送给之前会自动把它们拼接成最终的提示在内部使用类来处理用户和系统的文本并依赖一个给定的实现来用运行时提供的值替换变量默认情况下使用实现它基于由开发的开源引擎内部用来表示一个模板化提示的对象这是渲染器或模板引擎的接口它的工作就是接收一个带占位符的模板和一堆参数然后输出最终的被填充好的字符串这是默认的渲染器实现它背后使用的是一个叫的成熟强大的开源库默认情况下无需关心这些内部实现会自动用帮你处理格式的占位符也提供了一个用于不需要任何模板处理的情况直接在上配置的通过仅适用于直接在构建器链中定义的提示内容例如通过它不影响像这样的顾问内部使用的模板这些顾问有它们自己的模板定制机制请参阅自定义顾问模板如果您倾向于使用不同的模板引擎您可以直接向提供一个自定义的接口实现您也可以继续使用默认的但使用自定义的配置这里提到了两种常见的定制需求根本不想要模板功能场景你的提示内容本身就包含比如你正在向提问关于泛型或的问题默认的模板引擎可能会误以为这些是占位符从而导致错误解决方案使用是的缩写意思是啥也别干这个渲染器会原封不动地返回你的文本不做任何替换更换占位符的分隔符场景和上面类似为了避免与你的提示内容特别是冲突你想换一种更安全的分隔符比如解决方案你可以不更换整个引擎而是重新配置默认的告诉别用默认的渲染器了用我这个定制版的获取一个的建造者把开始符号从改成把结束符号从改成创建这个定制版的渲染器实例重要提示当你这么做之后你的模板文本也必须同步修改把改成仅适用于直接在构建器链中定义的提示内容这句话的意思是你在一次调用中通过设置的渲染器只对这一次调用生效它是一个局部的一次性的配置它不会影响更高级的封装了自身逻辑的组件比如即的核心组件那些组件有自己独立的模板配置方式因为它们的模板通常更复杂例如默认情况下模板变量是通过语法来识别的如果您计划在提示中包含您可能想要使用不同的语法以避免与语法冲突例如您可以使用和作为定界符小总结基础用法使用作为占位符并通过方法传值实现动态提示核心原理背后由引擎驱动高级定制可以通过在单次调用中更换渲染器可以换成来禁用模板功能可以重新配置默认的来更换分隔符比如以避免与等语法冲突的返回值在上指定方法后对于响应类型有几种不同的选项这段话的核心是在发起同步调用之后为你提供了多条取货通道你可以根据自己的需求选择最合适的那一条来获取的响应我们用一个去餐厅吃饭的比喻来梳理这些选项假设你已经点完餐并告诉服务员可以上菜了现在你要决定如何享用这顿饭返回响应的内容只吃主菜比喻你对服务员说别的都别管直接把主菜比如牛排端上来就行返回用途最简单最常用当你只关心回答的核心文本内容时用这个就够了返回对象该对象包含多个生成结果以及关于响应的元数据例如用于创建该响应的数量不仅吃主菜还要看菜单和账单比喻你对服务员说把主菜端上来顺便把详细的菜单包含成分说明和本次消费的账单使用量也一起拿来返回用途当你需要监控成本看调试问题看元数据或处理返回的多个候选答案时使用返回一个对象该对象包含对象和的执行上下文让您能够访问在顾问执行期间使用的附加数据例如在流程中检索到的相关文档不仅要菜和账单还要知道厨师是谁采购员从哪买的菜比喻你对服务员说除了菜和账单我还要知道这道菜是哪个厨师团队做的他们为了做这道菜特意去哪个市场采购了哪些新鲜食材检索到的文档返回用途这是一个非常高级的选项当你使用了更复杂的组件比如的核心并且你需要获取这些组件在执行过程中的内部数据比如到底引用了哪些文档来生成答案时才会用到它普通用例几乎接触不到用于返回一个类型用于返回一个实体类型的集合用于返回一个特定的实体类型用于指定一个的实例以将字符串转换为实体类型让服务员把菜按我要求摆盘这是结构化输出的功能它有几种不同的摆盘方式按家庭分享餐摆盘比喻请把菜摆成一个家庭分享餐的样子里面要有多份单人套餐用途将响应转换成一个泛型集合比如按单人套餐摆盘比喻请把菜直接摆成一个单人套餐对象的样子给我用途将响应直接转换成一个普通的对象按我自带的图纸摆盘比喻别用你们餐厅的盘子了用我自带的这个设计图纸实例来摆盘用途这是一个更底层的定制选项当你有一个自己创建或配置的转换器实例时可以用它来指导转换过程这在使用流式处理结构化输出时见过您也可以调用方法来替代最后别忘了所有这些都是在同步之后使用的如果你想用异步流式的方式那就得把换成然后使用流式提供的对应方法的返回值在上指定方法后对于响应类型有几个选项方法把的所有返回类型都装进了一个叫的异步管道里你不再是一次性收到一个完整的结果而是会通过这个管道持续不断地收到一个个数据块我们继续用去餐厅吃饭的比喻但这次餐厅的服务模式升级了变成了回转寿司你坐在传送带旁边菜品会一片一片一盘一盘地传送到你面前返回一个该会持续发出由模型正在生成的字符串片段只拿传送带上的寿司肉返回比喻传送带上源源不断地传来一小片一小片的生鱼片字符串片段你只关心吃肉所以你只拿这些鱼片比如的回答是传送带可能会依次传来用途实现打字机效果这是最常见的流式用例你订阅这个每当一小段文本传来你就在界面上把它追加显示出来返回一个该会发出对象其中包含了关于响应的附加元数据传送带上不仅有寿司还有带说明的小盘子返回比喻传送带上传来的不再是裸露的鱼片而是一小盘一小盘的寿司每个盘子上不仅有寿司文本片段还可能贴着标签写着这是今天第一批金枪鱼这批的消耗是等等元数据用途当你需要在流式处理的过程中实时获取每一小块响应的元数据时使用比如你可能想在流结束时累加所有中间过程的消耗这比等到最后才拿到总的要更实时返回一个该会发出对象该对象包含对象和的执行上下文让您能够访问在顾问执行期间使用的附加数据例如在流程中检索到的相关文档传送带上不仅有盘子还有厨师的签名和采购记录返回比喻传送带上传来的盘子更加豪华了除了寿司和标签盘子底下还附带了一张卡片上面有主厨的签名以及这张卡片所用的鱼是今天早上从哪个码头检索到的文档采购的记录用途非常高级且罕见用于在流式场景下实时地想知道当前生成的这段话是参考了哪些文档片段这可以用来在界面上实现一种效果当的回答逐渐出现时旁边同步高亮显示它正在参考的原文同步之后异步之后区别是什么一次性拿到完整字符串通过管道持续收到字符串片段一次性拿到完整的带元数据的响应通过管道持续收到带元数据的响应片段一次性拿到完整的带执行上下文的响应通过管道持续收到带上下文的响应片段关键记忆点只是把的所有返回结果都用这个异步管道包装了起来选择哪个取决于你是想等所有菜都上齐了再吃同步还是想菜上来一道吃一道异步使用默认值在一个类中创建一个带有默认系统文本的可以简化运行时的代码通过设置默认值您在调用时只需要指定用户文本从而无需在您的运行时代码路径中为每个请求都设置系统文本这段话的核心思想是不要在每次对话时都重复告诉它的人设在应用启动时一次性配置好以后每次调用时它就自动带上这个人设了默认系统文本在下面的示例中我们将配置系统文本使其总是以海盗你是一个友好的聊天机器人要用一个海盗的口吻来回答问题的口吻回复为了避免在运行时代码中重复设置系统文本我们将在一个类中创建一个实例注解告诉这个类是专门用来做配置的请在启动时扫描它注解告诉请调用这个方法并把它的返回值作为一个一个由管理的对象放入你的容器中以便其他地方可以注入使用它这个的默认名字就是方法名注入通用的使用通用的来创建一个特制版的是核心它为这个即将被创建的实例设置了一个默认的系统提示就像给助理设定了默认人设你是一个友好的聊天机器人要用海盗的口吻回答问题创建并返回这个海盗版从到这个方法的输入是通用的输出是一个经过定制的具体的实例的魔力容器现在有了一个名为的特定当其他组件请求注入一个类型的对象时会把这个海盗版的实例提供给它集中配置所有关于海盗这个角色的设定都封装在了类里与业务逻辑完全分离以及一个用于调用它的成员变量构造函数注入注意看这里注入的不再是而是我们刚刚在类里通过定义好的那个具体的实例会自动找到那个海盗版的并注入进来看这里的调用链非常简洁看这里的调用链非常简洁完全不需要再写了因为注入的已经自带了海盗人设它在内部会自动把默认的系统提示和这里的用户提示组合起来再发送给注入的是成品不是工具直接注入了最终产品而不是用于构建的工具这让的职责更单一它只管使用不管创建运行时代码简化方法的实现非常干净只关注核心业务逻辑获取用户输入并调用所有关于角色扮演的模板代码都被消除了结果验证的返回结果完美地证明了这一点的回答充满了海盗的口吻说明我们设置的默认系统提示确实生效了当通过调用应用程序端点时结果是总结这个例子是理解和应用依赖注入和集中化配置思想的绝佳范本分离关注点类负责如何创建和配置客户端类负责如何使用客户端两者各司其职代码整洁通过将通用配置如提取到配置类中极大地简化了业务代码使其更易读更易维护依赖注入的力量通过和构造函数注入框架像一个智能的管道工自动地将配置好的海盗版连接到了需要它的地方带参数的默认系统文本在下面的示例中我们将在系统文本中使用一个占位符以便在运行时而不是在设计时指定回答的口吻这个例子的核心思想是我们可以预设一个半成品的人设模板然后在每次对话时再动态地填入最关键的那部分信息注意看这次的默认系统提示是一个模板而不是一个写死的句子我们预留了一个叫的坑位关键变化的内容从一个固定的字符串变成了包含占位符的模板字符串现在我们创建的不再是海盗版我们可以称之为演员版它知道自己需要扮演一个角色但具体扮演谁它在等待指令这不再是像那样直接提供一个全新的系统提示它的作用是我要对默认的系统提示进行补充或修改这是一个表达式代表一个专门用来配置系统提示的工具这句代码的意思是请找到默认系统提示模板里的那个叫的占位符然后用我从参数里拿到的变量的值去填充它当通过调用应用程序端点时结果是完整流程用户访问接收到请求变量的值是这行代码执行它把填入到了默认模板中最终发送给的实际系统提示变成了接收到这个指令开始模仿著名演员罗伯特德尼罗的经典台词来回答问题总结这个例子展示了一个非常强大和实用的模式在配置层定义一个通用的带占位符的默认模板设定好框架在业务层只关注填充模板中的动态部分而不需要重复整个模板的框架这种方式兼顾了代码的简洁性和运行时的灵活性你可以用同样的代码通过改变参数让模仿海盗莎士比亚牛仔宇航员而无需修改一行后端代码这是构建高度可定制化应用的关键技巧其他默认值在级别您可以指定默认的提示配置是一个强大的预设工作台你不仅可以预设系统提示人设还可以预设模型参数可用工具默认问题甚至是功能我们可以把想象成一个高度定制的智能助理机器人通过的系列方法你可以在它出厂前之前为它安装各种默认配件和默认程序传入定义在类中的可移植选项或者像中那样的模型特定选项有关模型特定的实现的更多信息请参考预设大脑的运行参数比喻预设机器人的思考模式比如默认是严谨模式还是创意模式默认使用哪个型号的大脑用途统一应用的响应风格避免在每次调用时都重复设置等参数用于在用户文本中引用该函数解释了函数的目的帮助模型选择正确的函数以获得准确响应参数是一个函数实例模型会在必要时执行它在应用程序上下文中定义的的名称给机器人预装工具和技能比喻给机器人安装一些默认就能使用的工具比如一个天气查询器或者计算器你还要给每个工具一份说明书让机器人知道什么时候该用哪个工具用途这是实现的关键让能够调用你写的代码来获取外部信息或执行操作预设之后这个机器人就默认拥有了这些超能力这些方法让您可以定义默认的用户文本允许您使用表达式来指定用户文本和任何默认参数预设一个开场白或默认问题比喻预设机器人每次启动时默认要处理的第一个任务用途比较少见但可能用于某些特定场景比如创建一个专门用于每日新闻总结的它的提示就是请为我总结今天的头条新闻这样调用时甚至连都可以省略顾问允许修改用于创建的数据的实现通过将与用户文本相关的上下文信息附加到提示中来启用检索增强生成模式此方法允许您定义一个来使用配置多个顾问顾问可以修改用于创建最终的数据让您可以指定一个来添加顾问例如它通过根据用户文本将相关上下文信息附加到提示中来支持检索增强生成给机器人配备一个外脑或研究助理功能比喻这是最强大的配件你给机器人配备了一个研究团队当机器人遇到它知识范围外的问题时这个研究团队会先去你的知识库向量数据库里查找相关资料然后把资料整理好交给机器人让它根据这些新资料来回答问题用途启用检索增强生成通过预设一个你创建的就天生具备了结合你私有数据来回答问题的能力运行时覆盖默认值您可以在运行时使用相应的去掉了前缀的方法来覆盖这些默认值核心原则这是最需要记住的一点在上调用用于配置时设置全局默认值这是一次性岗前培训例如你是海盗没有前缀在的调用链中调用用于运行时提供单次调用的特定值这个特定值会覆盖本次调用的全局默认值这是下达临时指令例如这次别当海盗了扮演个牛仔这个设计提供了完美的平衡对于通用行为在配置中用设置一次一劳永逸对于特殊情况在运行时用灵活地进行单次覆盖而不影响全局默认设置总结不仅仅是一个简单的建造者它是一个功能丰富的配置中心通过它的系列方法你可以创建一个高度定制化功能强大的实例它天生就具备特定的性格固定的思考模式强大的外部工具连接私有知识库的能力掌握了这些你就可以根据不同的业务场景创建出多个各司其职高度专业化的智能助理让你的应用架构变得清晰强大且易于维护',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-22 00:55:21',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/avatar.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">XyreOS</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/img/qrcode-wechat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/qrcode-wechat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI-Song-Maker-%E5%9C%A8%E7%BA%BFAI%E6%AD%8C%E6%9B%B2%E7%94%9F%E6%88%90%E5%99%A8/" style="font-size: 1.05rem;">AI Song Maker-在线AI歌曲生成器<sup>1</sup></a><a href="/tags/CSDN%E6%96%87%E7%AB%A0%E8%A7%A3%E9%94%81%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">CSDN文章解锁工具<sup>1</sup></a><a href="/tags/Char%E5%92%8CCharacter/" style="font-size: 1.05rem;">Char和Character<sup>1</sup></a><a href="/tags/Chrome%E4%B8%80%E9%94%AE%E8%A7%A3%E9%99%A4%E5%A4%8D%E5%88%B6/" style="font-size: 1.05rem;">Chrome一键解除复制<sup>1</sup></a><a href="/tags/ComicBrief-AI%E6%BC%AB%E7%94%BB%E7%94%9F%E6%88%90%E5%99%A8/" style="font-size: 1.05rem;">ComicBrief-AI漫画生成器<sup>1</sup></a><a href="/tags/DeepWiki-github%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6/" style="font-size: 1.05rem;">DeepWiki-github百科全书<sup>1</sup></a><a href="/tags/Deskreen-%E7%94%B5%E8%84%91%E6%97%A0%E7%BA%BF%E5%89%AF%E5%B1%8F%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">Deskreen-电脑无线副屏工具<sup>1</sup></a><a href="/tags/Excel%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%86%99/" style="font-size: 1.05rem;">Excel自动填写<sup>1</sup></a><a href="/tags/FastFind-%E5%85%A8%E7%9B%98%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E8%BD%AF%E4%BB%B6/" style="font-size: 1.05rem;">FastFind-全盘文件搜索软件<sup>1</sup></a><a href="/tags/Get-Z-Library/" style="font-size: 1.05rem;">Get Z-Library<sup>1</sup></a><a href="/tags/HTTP/" style="font-size: 1.05rem;">HTTP<sup>1</sup></a><a href="/tags/Hexo/" style="font-size: 1.05rem;">Hexo<sup>1</sup></a><a href="/tags/InputTip-%E4%B8%80%E4%B8%AA%E5%AE%9E%E6%97%B6%E7%9A%84%E8%BE%93%E5%85%A5%E6%B3%95%E7%8A%B6%E6%80%81%E6%8F%90%E7%A4%BA%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">InputTip-一个实时的输入法状态提示工具<sup>1</sup></a><a href="/tags/Integer%E5%92%8Cint/" style="font-size: 1.05rem;">Integer和int<sup>1</sup></a><a href="/tags/JDBC/" style="font-size: 1.05rem;">JDBC<sup>2</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>1</sup></a><a href="/tags/Java%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 1.05rem;">Java面试题<sup>1</sup></a><a href="/tags/Mindows-%E7%BB%99%E4%BD%A0%E7%9A%84Android%E5%88%B7%E4%B8%8AWindows/" style="font-size: 1.05rem;">Mindows-给你的Android刷上Windows<sup>1</sup></a><a href="/tags/MyPublicWiFi-%E2%80%93-%E5%8A%9F%E8%83%BD%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%97%A0%E7%BA%BF%E7%83%AD%E7%82%B9%E5%85%B1%E4%BA%AB%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">MyPublicWiFi – 功能强大的无线热点共享工具<sup>1</sup></a><a href="/tags/NovaAI%E5%B7%A5%E5%85%B7%E7%AE%B1/" style="font-size: 1.05rem;">NovaAI工具箱<sup>1</sup></a><a href="/tags/PortableApps%EF%BC%88%E4%BE%BF%E6%90%BA%E5%BC%8F%E5%BA%94%E7%94%A8%EF%BC%89%E4%B8%80%E4%B8%AA%E5%85%8D%E8%B4%B9%E7%9A%84%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%AB%99/" style="font-size: 1.05rem;">PortableApps（便携式应用）一个免费的软件下载网站<sup>1</sup></a><a href="/tags/Servlet/" style="font-size: 1.05rem;">Servlet<sup>1</sup></a><a href="/tags/Spring-AI-%E5%8F%82%E8%80%83-%E8%81%8A%E5%A4%A9%E5%AE%A2%E6%88%B7%E7%AB%AFAPI/" style="font-size: 1.05rem;">Spring AI-参考-聊天客户端API<sup>1</sup></a><a href="/tags/Spring-AI%E4%B9%8B%E5%BC%80%E5%A7%8B/" style="font-size: 1.05rem;">Spring AI之开始<sup>1</sup></a><a href="/tags/Spring-AI%E4%B9%8B%E6%A6%82%E8%BF%B0-AI%E6%A6%82%E5%BF%B5/" style="font-size: 1.05rem;">Spring AI之概述-AI概念<sup>1</sup></a><a href="/tags/TrimSpace-%E5%85%8D%E8%B4%B9%E5%9C%A8%E7%BA%BF%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">TrimSpace-免费在线图片处理工具<sup>1</sup></a><a href="/tags/ZIPCracker-%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%96%87%E4%BB%B6%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">ZIPCracker-强大的文件密码破解工具<sup>1</sup></a><a href="/tags/animefeet/" style="font-size: 1.05rem;">animefeet<sup>1</sup></a><a href="/tags/leetcode/" style="font-size: 1.05rem;">leetcode<sup>24</sup></a><a href="/tags/remove-photos/" style="font-size: 1.05rem;">remove.photos<sup>1</sup></a><a href="/tags/win%E7%B3%BB%E7%BB%9F%E6%A1%8C%E9%9D%A2%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">win系统桌面管理工具<sup>1</sup></a><a href="/tags/zPaste-Windows%E5%89%AA%E5%88%87%E6%9D%BF%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">zPaste-Windows剪切板管理工具<sup>1</sup></a><a href="/tags/%E4%B8%80%E9%94%AE%E6%BF%80%E6%B4%BB-JetBrains-%E5%85%A8%E5%AE%B6%E6%A1%B6/" style="font-size: 1.05rem;">一键激活 JetBrains 全家桶<sup>1</sup></a><a href="/tags/%E4%B8%8A%E7%8F%AD%E7%9C%8B%E5%B0%8F%E8%AF%B4%E9%98%85%E8%AF%BB%E5%99%A8-%E9%9A%90%E8%94%BD%E5%BC%8F%E5%B0%8F%E8%AF%B4%E9%98%85%E8%AF%BB%E5%99%A8/" style="font-size: 1.05rem;">上班看小说阅读器-隐蔽式小说阅读器<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E7%BE%8E%E5%8C%96/" style="font-size: 1.05rem;">代码美化<sup>1</sup></a><a href="/tags/%E5%9C%A8%E7%BA%BF%E6%9D%A1%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">在线条码生成工具<sup>1</sup></a><a href="/tags/%E5%9C%A8%E7%BA%BF%E7%94%B5%E5%AD%90%E4%B9%A6%E9%98%85%E8%AF%BB/" style="font-size: 1.05rem;">在线电子书阅读<sup>1</sup></a><a href="/tags/%E5%AE%9E%E6%97%B6%E5%B7%A5%E8%B5%84%E8%AE%A1%E7%AE%97%E5%99%A8/" style="font-size: 1.05rem;">实时工资计算器<sup>1</sup></a><a href="/tags/%E7%A4%BA%E4%BE%8B/" style="font-size: 1.05rem;">示例<sup>1</sup></a><a href="/tags/%E8%B7%AF%E5%BE%84%E5%A4%84%E7%90%86/" style="font-size: 1.05rem;">路径处理<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">35</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">14</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">21</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">转载</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring-AI/" itemprop="url">Spring AI</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Spring-AI-%E5%8F%82%E8%80%83-%E8%81%8A%E5%A4%A9%E5%AE%A2%E6%88%B7%E7%AB%AFAPI/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Spring AI-参考-聊天客户端API</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Spring AI-参考-聊天客户端API</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-06-16T01:59:02.000Z" title="发表于 2025-06-16 09:59:02">2025-06-16</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-06-21T16:55:21.000Z" title="更新于 2025-06-22 00:55:21">2025-06-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">15.9k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>54分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为重庆"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>重庆</span></div></div></div><article class="post-content" id="article-container" itemscope itemtype="https://xyre.online/2025/06/16/Spring%20AI/Spring-AI-%E5%8F%82%E8%80%83-%E8%81%8A%E5%A4%A9%E5%AE%A2%E6%88%B7%E7%AB%AFAPI/"><header><a class="post-meta-categories" href="/categories/Spring-AI/" itemprop="url">Spring AI</a><a href="/tags/Spring-AI-%E5%8F%82%E8%80%83-%E8%81%8A%E5%A4%A9%E5%AE%A2%E6%88%B7%E7%AB%AFAPI/" tabindex="-1" itemprop="url">Spring AI-参考-聊天客户端API</a><h1 id="CrawlerTitle" itemprop="name headline">Spring AI-参考-聊天客户端API</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Re-xy</span><time itemprop="dateCreated datePublished" datetime="2025-06-16T01:59:02.000Z" title="发表于 2025-06-16 09:59:02">2025-06-16</time><time itemprop="dateCreated datePublished" datetime="2025-06-21T16:55:21.000Z" title="更新于 2025-06-22 00:55:21">2025-06-22</time></header><h1 id="聊天客户端API"><a href="#聊天客户端API" class="headerlink" title="聊天客户端API"></a>聊天客户端API</h1><p>ChatClient 提供了一个流式 API（fluent API）用于与 AI 模型进行通信。它同时支持同步和流式两种编程模型。</p>
<blockquote>
<p>请参阅本文档底部的“实现说明(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/chatclient.html#_implementation_notes)%E2%80%9D%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%B6%89%E5%8F%8A%E5%9C%A8">https://docs.spring.io/spring-ai/reference/api/chatclient.html#_implementation_notes)”，其中涉及在</a> ChatClient 中结合使用命令式和响应式编程模型的相关内容。</p>
</blockquote>
<p>这个流式 API 提供了一些方法，用于构建一个 Prompt（<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/prompt.html#_prompt%EF%BC%89%E7%9A%84%E5%90%84%E4%B8%AA%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%EF%BC%8C%E8%BF%99%E4%B8%AA">https://docs.spring.io/spring-ai/reference/api/prompt.html#_prompt）的各个组成部分，这个</a> Prompt 将作为输入传递给 AI 模型。Prompt 中包含了指导性文本，用以引导 AI 模型的输出和行为。从 API 的角度来看，提示是由一系列消息组成的。</p>
<p>AI 模型主要处理两种类型的消息：用户消息（user messages），即来自用户的直接输入；以及系统消息（system messages），由系统生成用以引导对话。</p>
<p>这些消息通常包含占位符，这些占位符会在运行时根据用户输入被替换，从而根据用户输入定制化 AI 模型的响应。<br>此外，还可以指定一些提示选项（Prompt options），例如要使用的 AI 模型的名称，以及用于控制生成输出的随机性或创造力的“温度”（temperature）设置。</p>
<blockquote>
<ol>
<li><p>核心组件：ChatClient</p>
<p>这个组件是用来和AI模型(例如OpenAI的GPT-4)聊天的接口。</p>
</li>
<li><p>两大编程模型：同步 vs. 流式</p>
<ul>
<li>同步 (Synchronous)：你问一个问题，然后一直等着，直到 AI 把完整的答案一次性全部给你。这就像下载一个文件，必须等它 100% 下载完才能打开。</li>
</ul>
</li>
</ol>
<ul>
<li>流式 (Streaming)：你问一个问题，AI 一边思考一边回答，把答案一个词一个词地吐给你。这就像看在线视频，视频内容是流式传输过来的，你不用等整个视频下载完就能开始看。ChatGPT 网站的打字机效果就是典型的流式响应。</li>
</ul>
<ol start="3">
<li><p>核心交互方式：流式 API (Fluent API)</p>
<p>“Fluent API” 也常被称为“链式调用”。它的特点是你可以像链条一样把多个方法调用串在一起，让代码读起来像自然语言一样流畅。</p>
</li>
</ol>
<p><strong>以下写一个伪代码来方便理解：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">answer</span> <span class="operator">=</span> chatClient.prompt()</span><br><span class="line">    .system(<span class="string">&quot;你是一个专业的诗人&quot;</span>) <span class="comment">// 先设置系统角色</span></span><br><span class="line">    .user(<span class="string">&quot;写一首关于春天的五言绝句&quot;</span>) <span class="comment">// 再提供用户问题</span></span><br><span class="line">    .call() <span class="comment">// 发起调用</span></span><br><span class="line">    .content(); <span class="comment">// 获取结果</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>核心输入结构：Prompt 和 Message</li>
</ol>
<ul>
<li>Prompt（提示）：可以理解为你要发送给 AI 的整个请求包裹。</li>
<li>Message（消息）：是这个包裹里的具体内容，可以有多条。</li>
</ul>
<p>  一个 Prompt 对象里，通常会包含一个或多个 Message 对象。<br>5. 两种主要消息类型：User vs. System<br>  这是 Prompt Engineering 的核心概念：</p>
<ul>
<li>User Message (用户消息)：就是你（用户）对 AI 说的话，比如“帮我翻译一下这句话”、“写一段代码”。</li>
<li>System Message (系统消息)：这是你给 AI 设定的**“人设”或“行为准则”**。它在对话开始前告诉 AI：“你接下来要扮演一个什么样的角色，遵守什么样的规则”。比如：</li>
<li><ul>
<li>“你是一个从不讲笑话的严肃历史学家。”</li>
</ul>
</li>
<li><ul>
<li>“你的所有回答都必须使用中文，并且格式为 JSON。”</li>
</ul>
</li>
</ul>
<ol start="6">
<li>动态化：占位符 (Placeholders)<br>  你可以在消息文本里预留一些“坑”（占位符），比如 Tell me a joke about {topic}.。在实际调用时，再把 {topic} 替换成具体的值，比如 “cats” 或者 “programmers”。这让你的提示可以被复用。</li>
<li>精细控制：提示选项 (Prompt Options)<br>  除了对话内容，你还可以设置一些“超参数”来微调 AI 的行为：</li>
</ol>
<ul>
<li>model (模型名称)：指定你要用哪个 AI 模型，比如 gpt-4o 还是 gpt-3.5-turbo。</li>
<li>temperature (温度)：这是一个非常重要的参数，控制 AI 回答的创造性或随机性。</li>
<li><ul>
<li>低温 (比如 0.1)：AI 的回答会非常确定、严谨、重复性高，适合需要事实和精确答案的场景。</li>
</ul>
</li>
<li><ul>
<li>高温 (比如 0.9)：AI 的回答会更有创意、更天马行空、更多样化，适合头脑风暴、写故事等场景。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="创建ChatClient"><a href="#创建ChatClient" class="headerlink" title="创建ChatClient"></a>创建ChatClient</h2><p>ChatClient 是使用 ChatClient.Builder 对象创建的。您可以为任何 ChatModel(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/chatmodel.html">https://docs.spring.io/spring-ai/reference/api/chatmodel.html</a>) Spring Boot 自动配置获取自动配置的 ChatClient.Builder 实例，或者以编程方式创建一个实例。</p>
<h3 id="使用自动配置的-ChatClient-Builder"><a href="#使用自动配置的-ChatClient-Builder" class="headerlink" title="使用自动配置的 ChatClient.Builder"></a>使用自动配置的 ChatClient.Builder</h3><p>在最简单的用例中， Spring AI 提供 Spring Boot 自动配置，创建一个原型 ChatClient.Builder bean 供你注入到你的类中。下面是检索对简单用户请求的 String 响应的简单示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChatClient chatClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyController</span><span class="params">(ChatClient.Builder chatClientBuilder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.chatClient = chatClientBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/ai&quot;)</span></span><br><span class="line">    String <span class="title function_">generation</span><span class="params">(String userInput)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.chatClient.prompt()</span><br><span class="line">            .user(userInput)</span><br><span class="line">            .call()</span><br><span class="line">            .content();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个简单的示例中，用户输入设置用户消息的内容。call()方法向 AI 模型发送请求，content()方法将 AI 模型的响应作为 String 返回。</p>
<p>我现在来详细注释一下这个代码： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @RestController 是一个组合注解，它结合了 @Controller 和 @ResponseBody。</span></span><br><span class="line"><span class="comment">// @Controller: 告诉 Spring 这一个类是 MVC 模式中的控制器，负责处理 Web 请求。</span></span><br><span class="line"><span class="comment">// @ResponseBody: 告诉 Spring，这个类中所有方法的返回值都应该直接作为 HTTP 响应体的内容返回，</span></span><br><span class="line"><span class="comment">//               通常是 JSON、XML 或像本例中的纯文本，而不是去查找一个视图（如 JSP 或 Thymeleaf 模板）。</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// final 关键字声明 chatClient 是一个最终变量。这意味着它必须在对象构造时被初始化，</span></span><br><span class="line">    <span class="comment">// 且之后不能再被修改。这是一种推荐的编程实践，可以增强代码的健壮性和线程安全性。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChatClient chatClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个构造函数，Spring 框架会用它来创建 MyController 的实例。</span></span><br><span class="line">    <span class="comment">// 这也是 Spring 推荐的依赖注入方式——“构造函数注入”。</span></span><br><span class="line">    <span class="comment">// 参数 (ChatClient.Builder chatClientBuilder): 当 Spring 创建 MyController 时，</span></span><br><span class="line">    <span class="comment">// 它会自动在自己的“容器”中寻找一个 ChatClient.Builder 类型的 Bean，并把它作为参数传进来。</span></span><br><span class="line">    <span class="comment">// 这个 Builder 是由 Spring AI 的自动配置功能提前为我们准备好的，已经包含了所有必要的配置（如 API Key）。</span></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">//这个是可有可无的注释，因为从 Spring 4.3 版本开始，如果一个类只有一个构造函数，那么 Spring 就会自动使用这个构造函数来进行依赖注入，此时 @Autowired 注解是可选的，可以省略。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyController</span><span class="params">(ChatClient.Builder chatClientBuilder)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用注入的 Builder 对象，通过调用 build() 方法，来创建一个最终可用、配置完备的 ChatClient 实例。</span></span><br><span class="line">        <span class="comment">// 这个 build() 调用标志着配置阶段的结束和可用对象的诞生。</span></span><br><span class="line">        <span class="built_in">this</span>.chatClient = chatClientBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @GetMapping(&quot;/ai&quot;) 将这个方法映射到 HTTP GET 请求的 &quot;/ai&quot; 路径。</span></span><br><span class="line">    <span class="comment">// 当用户访问 &quot;http://your-server/ai&quot; 时，这个方法就会被触发。</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/ai&quot;)</span></span><br><span class="line">    <span class="comment">//@GetMapping：处理 GET 请求（获取数据）</span></span><br><span class="line">    <span class="comment">//@PostMapping：处理 POST 请求（新建数据）</span></span><br><span class="line">    <span class="comment">//@PutMapping：处理 PUT 请求（更新数据）</span></span><br><span class="line">    <span class="comment">//@DeleteMapping：处理 DELETE 请求（删除数据）</span></span><br><span class="line">    <span class="comment">//@PatchMapping：处理 PATCH 请求（部分更新数据）</span></span><br><span class="line">    <span class="comment">//@RequestMapping 是最基础的请求映射注解，它可以用来处理 任何类型 的 HTTP 请求。</span></span><br><span class="line">    <span class="comment">// 这行代码...</span></span><br><span class="line">    <span class="comment">//@RequestMapping(value = &quot;/ai&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="comment">//public String handleGetRequest() &#123;</span></span><br><span class="line">    <span class="comment">//    return &quot;只处理 GET 请求&quot;;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...就完全等同于我们之前学的 @GetMapping</span></span><br><span class="line">    <span class="comment">//@GetMapping(&quot;/ai&quot;)</span></span><br><span class="line">    <span class="comment">//public String handleGetRequest() &#123;</span></span><br><span class="line">    <span class="comment">//    return &quot;只处理 GET 请求&quot;;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">// Spring MVC 会自动将 URL 中的查询参数（如 ?userInput=...）的值赋给同名的`userInput`方法参数。</span></span><br><span class="line">    <span class="comment">// 例如，访问 /ai?userInput=Hello，则 userInput 的值就是 &quot;Hello&quot;。</span></span><br><span class="line">    String <span class="title function_">generation</span><span class="params">(String userInput)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// --- 这是整个案例最核心的一行，体现了 Spring AI 的链式 API 设计 ---</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. this.chatClient.prompt():</span></span><br><span class="line">        <span class="comment">//    - 获取我们已经创建好的 chatClient 实例。</span></span><br><span class="line">        <span class="comment">//    - 调用 prompt() 方法，这表示：“我要开始构建一个新的 AI 请求（Prompt）了”。</span></span><br><span class="line">        <span class="comment">//    - 它返回一个可以继续配置请求的中间对象。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. .user(userInput):</span></span><br><span class="line">        <span class="comment">//    - 在这个新的请求中，添加一条“用户消息”（User Message）。</span></span><br><span class="line">        <span class="comment">//    - 消息的内容就是从 URL 参数中获取的 userInput 字符串。</span></span><br><span class="line">        <span class="comment">//    - 这是在告诉 AI：“这是用户对你提出的问题或指令”。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. .call():</span></span><br><span class="line">        <span class="comment">//    - 这是触发器，表示“我的请求已经构建完毕，现在请把它发送给 AI 模型”。</span></span><br><span class="line">        <span class="comment">//    - 这是一个【同步阻塞】调用。意味着程序会在这里暂停，一直等到 AI 模型处理完请求，</span></span><br><span class="line">        <span class="comment">//      并返回完整的响应后，代码才会继续往下执行。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. .content():</span></span><br><span class="line">        <span class="comment">//    - .call() 方法返回的是一个包含所有响应信息的对象（比如 ChatResponse）。</span></span><br><span class="line">        <span class="comment">//    - .content() 方法则是从这个响应对象中，提取出我们最关心的核心部分——AI 生成的【文本内容】。</span></span><br><span class="line">        <span class="comment">//    - 这个方法最终返回一个 java.lang.String。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.chatClient.prompt()</span><br><span class="line">            .user(userInput)</span><br><span class="line">            .call()</span><br><span class="line">            .content();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用多个聊天模型"><a href="#使用多个聊天模型" class="headerlink" title="使用多个聊天模型"></a>使用多个聊天模型</h3><p>在以下几种情况下，您可能需要在单个应用程序中使用多个聊天模型：</p>
<ul>
<li>对不同类型的任务使用不同的模型（例如，用于复杂推理的强大模型和用于简单任务的更快、更便宜的模型）</li>
<li>当一个模型服务不可用时实现回退机制</li>
<li>A&#x2F;B 测试不同的型号或配置</li>
<li>为用户提供基于其偏好的模型选择</li>
<li>组合专用模型（一个用于代码生成，另一个用于创意内容等）</li>
</ul>
<p>默认情况下，Spring AI 会自动配置单个 ChatClient.Builder Bean。但是，您可能需要在应用程序中使用多个聊天模型。以下是处理此情况的方法：</p>
<p>在所有情况下，您都需要通过设置属性 spring.ai.chat.client.enabled&#x3D;false 来禁用 ChatClient.Builder 自动配置。</p>
<p>这允许您手动创建多个 ChatClient 实例。</p>
<blockquote>
<p>解读：</p>
<p>当默认的“一个应用对应一个 AI 模型”的简单模式不够用时，Spring AI 提供了灵活的手动配置方式来支持更复杂的“多模型”场景。</p>
<ol>
<li><p>为什么要用多个模型？</p>
<p>原文列举了几个非常经典的理由：</p>
<p><strong>成本与性能的权衡 (Cost vs. Performance)</strong>：<strong>场景</strong>：做一个智能客服。对于简单的问候、查询订单等任务，用一个便宜快速的模型（如 GPT-3.5-Turbo）就够了。但如果用户提出复杂的投诉或需要深度分析的问题，就切换到更强大但更贵的模型（如 GPT-4o）。<strong>核心思想</strong>：好钢用在刀刃上，不同任务用不同工具。</p>
<p><strong>高可用性与容错 (High Availability &amp; Fault Tolerance)</strong>：<strong>场景</strong>：你的主要 AI 服务商（比如 OpenAI）突然宕机了。为了不影响用户，系统可以自动切换到备用的服务商（比如 Anthropic 的 Claude 或 Google 的 Gemini）。<strong>核心思想</strong>：不要把所有鸡蛋放在一个篮子里。</p>
<p><strong>实验与优化 (A&#x2F;B Testing)</strong>：<strong>场景</strong>：你不确定用模型 A 还是模型 B 的效果更好。你可以让 50% 的用户流量走模型 A，另外 50% 走模型 B，然后比较哪个的用户满意度更高或业务指标更好。<strong>核心思想</strong>：用数据说话，找到最优解。</p>
<p><strong>用户自定义 (User Customization)</strong>：<strong>场景</strong>：在你的应用里，像一个设置选项一样，让用户自己选择喜欢用“聪明但慢一点的 GPT-4o”还是“快一点但可能没那么聪明的 GPT-3.5”。<strong>核心思想</strong>：把选择权交给用户。</p>
<p><strong>专业分工 (Specialization)</strong>：<strong>场景</strong>：你的应用既能帮你写代码，又能帮你写诗。你可以配置一个专门为代码优化过的模型（如 codestral）来处理代码生成请求，同时用另一个擅长创意的模型（如 gpt-4o）来写诗。<strong>核心思想</strong>：让专业的人做专业的事。</p>
</li>
<li><p>如何实现？（The “How”）<br>理解了“为什么”之后，“怎么做”就成了关键。Spring AI 的解决方案非常直接：</p>
<p><strong>第一步：关闭默认的“傻瓜模式”</strong><br>默认行为：Spring AI 默认会自动配置好一个 ChatClient.Builder，让用户开箱即用。这很方便，但也限制了用户只能有一个“默认”的客户端。<br>需要做的：在application.properties 或 application.yml 文件里，加上这行配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.ai.chat.client.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<p>它的作用：这行配置等于告诉 Spring AI：“谢谢你的好意，但别再帮我自动创建那个默认的 ChatClient.Builder 了。接下来的事情，我自己来！”</p>
<p><strong>第二步：自己动手，丰衣足食</strong><br>一旦关闭了自动配置，你就获得了完全的自由。<br>你现在可以像创建任何普通的 Spring Bean 一样，在你的配置类 (@Configuration) 中，手动创建任意多个 ChatClient 实例。<br>每个实例都可以绑定到不同的底层 ChatModel（比如一个连 OpenAI，一个连 Ollama），或者绑定到同一个 ChatModel 但使用不同的默认设置（比如一个高温，一个低温）。</p>
<p><strong>总结</strong><br>这段内容是 Spring AI 从“入门”到“进阶”的一个重要转折点。<br>入门模式：依赖自动配置，快速搞定单个模型的集成。<br>进阶模式：</p>
<ul>
<li>自动配置 (spring.ai.chat.client.enabled&#x3D;false)。</li>
<li>手动创建和配置多个 ChatClient Bean，以满足复杂的业务需求。</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="针对单一模型类型的多个-ChatClient"><a href="#针对单一模型类型的多个-ChatClient" class="headerlink" title="针对单一模型类型的多个 ChatClient"></a>针对单一模型类型的多个 ChatClient</h4><p>本节介绍一个常见的用例，即您需要创建多个 ChatClient 实例，这些实例都使用相同的底层模型类型，但具有不同的配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以编程方式创建 ChatClient 实例</span></span><br><span class="line"><span class="comment">//由 Spring Boot 自动配置一个代表大模型的连接器 (ChatModel)，例如连接 GPT 的 OpenAiChatModel。然后，我们创建一个供开发者使用的、更友好的客户端 (ChatClient)，并将那个连接器 (ChatModel) 作为它的底层引擎，这样我们就可以通过 ChatClient 的简洁 API 来间接操作 ChatModel 发起请求了。</span></span><br><span class="line"><span class="comment">//它的用处就是帮你封装了一套“默认的、重复的”请求配置，让你在后续调用时，可以写出更简洁、更专注于业务变化的代码。</span></span><br><span class="line"><span class="type">ChatModel</span> <span class="variable">myChatModel</span> <span class="operator">=</span> ... <span class="comment">// 已由 Spring Boot 自动配置</span></span><br><span class="line"><span class="type">ChatClient</span> <span class="variable">chatClient</span> <span class="operator">=</span> ChatClient.create(myChatModel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 builder 来获得更多控制</span></span><br><span class="line">ChatClient.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> ChatClient.builder(myChatModel);</span><br><span class="line"><span class="type">ChatClient</span> <span class="variable">customChatClient</span> <span class="operator">=</span> builder</span><br><span class="line">    .defaultSystemPrompt(<span class="string">&quot;你是一个乐于助人的助手。&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>第一种方法：</strong><br><strong>核心目的</strong>: 快速、直接地创建一个基础的 ChatClient 实例，不包含任何预设的默认配置。<br><strong>实现方式</strong>: 通过 ChatClient 接口的静态工厂方法 create(ChatModel model)。<br><strong>最终产物</strong>: 一个“标准版”或“裸版”的 ChatClient。它是一个功能完备的客户端，但没有任何个性化设置。<br><strong>适用场景</strong>: 当你的 AI 请求每次都完全不同，或者你倾向于在每次调用时都明确指定所有参数（如系统提示、模型选项等），不希望有任何隐藏的默认行为时。</p>
<hr>
<p><strong>第二种方法：</strong><br><strong>核心目的:</strong> 创建一个带有预设默认配置（例如默认系统提示、默认模型参数等）的、可复用的 ChatClient 实例。<br><strong>实现方式:</strong> 采用建造者设计模式 (Builder Pattern)。</p>
<ul>
<li>ChatClient.builder(myChatModel): 启动构建过程，返回一个 Builder 对象。</li>
<li>.defaultSystemPrompt(…): 在 Builder上进行链式调用，以声明所需的默认配置。</li>
<li>.build(): 完成构建，生成最终的 ChatClient 实例。<br><strong>最终产物:</strong> 一个“定制版”或“智能版”的 ChatClient。这个实例内部封装了你在构建时设定的默认值。<br><strong>适用场景:</strong> 当你有一类相似的 AI 请求（例如，所有的客服对话、所有的代码翻译任务），它们总是需要共享相同的背景指令或参数时。使用这种方式可以极大地简化后续的调用代码，避免重复设置。</li>
</ul>
</blockquote>
<p>用于不同模型类型的 ChatClient<br>当使用多个 AI 模型时，您可以为每个模型定义单独的 ChatClient bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.ai.chat.ChatClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatClientConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>	<span class="comment">//openai</span></span><br><span class="line">    <span class="keyword">public</span> ChatClient <span class="title function_">openAiChatClient</span><span class="params">(OpenAiChatModel chatModel)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChatClient.create(chatModel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>	<span class="comment">//anthropic</span></span><br><span class="line">    <span class="keyword">public</span> ChatClient <span class="title function_">anthropicChatClient</span><span class="params">(AnthropicChatModel chatModel)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChatClient.create(chatModel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，您可以使用 @Qualifier 注解将这些 bean 注入到您的应用程序组件中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatClientExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    CommandLineRunner <span class="title function_">cli</span><span class="params">(</span></span><br><span class="line"><span class="params">            //第一个工具：指名道姓要 <span class="string">&quot;openAiChatClient&quot;</span> 这个 ChatClient</span></span><br><span class="line"><span class="params">        	<span class="meta">@Qualifier(&quot;openAiChatClient&quot;)</span> ChatClient openAiChatClient,</span></span><br><span class="line"><span class="params">        	//第二个工具：指名道姓要 <span class="string">&quot;anthropicChatClient&quot;</span> 这个 ChatClient</span></span><br><span class="line"><span class="params">        	<span class="meta">@Qualifier(&quot;anthropicChatClient&quot;)</span> ChatClient anthropicChatClient)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            ChatClient chat;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模型选择</span></span><br><span class="line">            System.out.println(<span class="string">&quot;\n选择您的 AI 模型:&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;1. OpenAI&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;2. Anthropic&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;输入您的选择 (1 或 2): &quot;</span>);</span><br><span class="line">		   </span><br><span class="line">            <span class="comment">//trim() 去掉前后的空格</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">choice</span> <span class="operator">=</span> scanner.nextLine().trim();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (choice.equals(<span class="string">&quot;1&quot;</span>)) &#123;</span><br><span class="line">                chat = openAiChatClient;</span><br><span class="line">                System.out.println(<span class="string">&quot;正在使用 OpenAI 模型&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                chat = anthropicChatClient;</span><br><span class="line">                System.out.println(<span class="string">&quot;正在使用 Anthropic 模型&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用选定的聊天客户端</span></span><br><span class="line">            System.out.print(<span class="string">&quot;\n输入您的问题: &quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> chat.prompt(input).call().content();</span><br><span class="line">            System.out.println(<span class="string">&quot;助手: &quot;</span> + response);</span><br><span class="line"></span><br><span class="line">            scanner.close();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一句话总结 @Qualifier(…)：<br>它是一个“消除歧义”的注解。在有多个同类型 Bean 的情况下，通过指定 Bean 的名字，来精确地注入你想要的那一个。</p>
<hr>
<p><strong>来讲解一下这个步骤：</strong><br><strong>String response &#x3D; chat.prompt(input).call().content();</strong><br><strong>第一步：<strong>chat.prompt(input)<br><strong>例如我想问ai，今天的天气如何？</strong><br>prompt 这个词，在 AI 领域，它的标准翻译是</strong>“提示”或“提示语”。它不仅仅是关键词，而是你希望 AI 对其作出回应的完整指令或上下文</strong>。<br>chat.prompt(input) 这段代码，其实是一个语法糖（shorthand），<strong>它等价于 chat.prompt().user(input)。</strong><br>chat.prompt(): 动作是“准备一封新信件”（创建一个新的 Prompt 请求对象）。<br>.user(input): 动作是“在这封信的用户提问区，写上 input 的内容”。<br>所以，当你写 chat.prompt(“今天的天气如何？”) 时，你实际上是在创建一个请求，这个请求里包含了一条用户消息（User Message），内容就是 “今天的天气如何？”。</p>
<p><strong>第二步：.call()</strong><br>call 的意思是**“调用”或“执行”。它是整个流程的“发送”按钮**。<br>它的作用：告诉 ChatClient：“我的信（Prompt）已经准备好了，现在请你把它发送给 AI 模型，然后在原地等待，直到你收到 AI 完整的回信。”<br>它的性质：这是一个<strong>同步阻塞（Synchronous &amp; Blocking）<strong>的操作。<br>同步：意味着它会一次性返回完整的结果，而不是一点一点地返回。<br>阻塞：意味着你的程序代码在执行到 .call() 时会暂停，就像卡住了一样，直到网络另一头的 AI 模型把所有文字都生成完毕，并将结果传回你的程序，你的代码才会继续往下走。<br>它的返回值：.call() 执行完毕后，返回的不是一个简单的字符串，而是一个包含了所有响应信息的</strong>“包裹”</strong>，这个包裹的类型是 ChatResponse。这个包裹里除了有 AI 回答的文本内容，可能还有其他信息，比如这次调用消耗了多少 Token、调用是否成功、AI 决定停止回答的原因等等。</p>
<p><strong>第三步：.content()</strong><br>content 的意思是“内容”。它是整个流程的“拆信封”动作。<br>它的作用：从上一步 .call() 返回的那个响应“包裹” (ChatResponse) 中，提取出我们最关心的核心部分——AI 生成的文本内容。<br>它的性质：这是一个简单的数据提取操作。<br>它的返回值：.content() 方法最终返回一个我们最熟悉的 <strong>java.lang.String</strong> 对象，这个字符串就是 AI 对你问题的回答，比如 “很抱歉，我无法获取实时的天气信息…”。</p>
</blockquote>
<h4 id="多个兼容-OpenAI-的-API-端点"><a href="#多个兼容-OpenAI-的-API-端点" class="headerlink" title="多个兼容 OpenAI 的 API 端点"></a>多个兼容 OpenAI 的 API 端点</h4><p>OpenAiApi 和 OpenAiChatModel 类提供了一个 mutate() 方法，它允许您创建现有实例的、具有不同属性的变体。当您需要与多个兼容 OpenAI 的 API 协同工作时，这个功能特别有用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiModelService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MultiModelService.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OpenAiChatModel baseChatModel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OpenAiApi baseOpenAiApi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multiClientFlow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 为 Groq (Llama3) 派生一个新的 OpenAiApi</span></span><br><span class="line">            <span class="type">OpenAiApi</span> <span class="variable">groqApi</span> <span class="operator">=</span> baseOpenAiApi.mutate()</span><br><span class="line">                .baseUrl(<span class="string">&quot;https://api.groq.com/openai&quot;</span>)</span><br><span class="line">                .apiKey(System.getenv(<span class="string">&quot;GROQ_API_KEY&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为 OpenAI GPT-4 派生一个新的 OpenAiApi</span></span><br><span class="line">            <span class="type">OpenAiApi</span> <span class="variable">gpt4Api</span> <span class="operator">=</span> baseOpenAiApi.mutate()</span><br><span class="line">                .baseUrl(<span class="string">&quot;https://api.openai.com&quot;</span>)</span><br><span class="line">                .apiKey(System.getenv(<span class="string">&quot;OPENAI_API_KEY&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为 Groq 派生一个新的 OpenAiChatModel</span></span><br><span class="line">            <span class="type">OpenAiChatModel</span> <span class="variable">groqModel</span> <span class="operator">=</span> baseChatModel.mutate()</span><br><span class="line">                .openAiApi(groqApi)</span><br><span class="line">                .defaultOptions(OpenAiChatOptions.builder().model(<span class="string">&quot;llama3-70b-8192&quot;</span>).temperature(<span class="number">0.5</span>).build())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为 GPT-4 派生一个新的 OpenAiChatModel</span></span><br><span class="line">            <span class="type">OpenAiChatModel</span> <span class="variable">gpt4Model</span> <span class="operator">=</span> baseChatModel.mutate()</span><br><span class="line">                .openAiApi(gpt4Api)</span><br><span class="line">                .defaultOptions(OpenAiChatOptions.builder().model(<span class="string">&quot;gpt-4&quot;</span>).temperature(<span class="number">0.7</span>).build())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为两个模型准备一个简单的提示</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">prompt</span> <span class="operator">=</span> <span class="string">&quot;法国的首都是哪里？&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">groqResponse</span> <span class="operator">=</span> ChatClient.builder(groqModel).build().prompt(prompt).call().content();</span><br><span class="line">            <span class="type">String</span> <span class="variable">gpt4Response</span> <span class="operator">=</span> ChatClient.builder(gpt4Model).build().prompt(prompt).call().content();</span><br><span class="line"></span><br><span class="line">            logger.info(<span class="string">&quot;Groq (Llama3) 的回答: &#123;&#125;&quot;</span>, groqResponse);</span><br><span class="line">            logger.info(<span class="string">&quot;OpenAI GPT-4 的回答: &#123;&#125;&quot;</span>, gpt4Response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;在多客户端流程中出错&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这段代码解决了一个非常有趣的问题：现在市面上有很多新兴的 AI 服务（比如 Groq、Together AI、Perplexity 等），它们为了方便开发者迁移，都提供了<strong>兼容 OpenAI API 规范</strong>的接口。这意味着，你可以用和调用 OpenAI 完全相同的代码结构去调用它们，只需要<strong>更换 API 地址 (Base URL) 和 API 密钥 (API Key)</strong> 即可。<br>这段代码的核心就是展示如何利用 Spring AI 的 .mutate() 方法，优雅地实现这种动态切换。<br><strong>核心概念：.mutate() 方法</strong></p>
<ul>
<li>mutate() 的意思是“变异”或“派生”。它是一种“以我为模板，创建一个稍作修改的新副本”的设计模式（类似于原型模式）。</li>
<li>当你调用 someObject.mutate() 时，它会返回一个 Builder 对象，这个 Builder 的初始状态完全继承了 someObject 的所有属性。</li>
<li>然后，你可以对这个 Builder 进行局部修改，最后调用 .build() 来生成一个全新的、修改后的实例，而原始的 someObject 保持不变。</li>
</ul>
</blockquote>
<h2 id="ChatClient-流式-API"><a href="#ChatClient-流式-API" class="headerlink" title="ChatClient 流式 API"></a>ChatClient 流式 API</h2><p>ChatClient 流式 API 允许您通过一个重载的 prompt 方法，以三种不同的方式来创建一个提示（Prompt），从而启动流式 API 的调用链：</p>
<ol>
<li><strong>prompt()</strong>: 这个无参数的方法让您可以开始使用流式 API，允许您逐步构建用户消息、系统消息以及提示的其他部分。</li>
</ol>
<blockquote>
<ol>
<li>prompt(): 完全自定义点餐<br> 代码：chatClient.prompt()<br> 比喻：你走到点餐台前，对服务员说：“我要开始点餐了”。然后你开始一步步地告诉他：“我要一个汉堡（.user()），不要酸黄瓜，加双份芝士（各种 .option()），再来一杯可乐（另一个 .user() 或工具调用），对了，记得提醒厨师我是你们的超级会员，口味要重一点（.system()）。”<br> 使用场景：这是最灵活、最常用的方式。你需要从零开始构建一个复杂的请求，包含系统消息、用户消息、各种选项等。链式调用的所有功能都可以从这个起点开始。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;chatClient.prompt() <span class="comment">// &lt;--- 起点</span></span><br><span class="line">   .system(<span class="string">&quot;你是一个专业的翻译家&quot;</span>)</span><br><span class="line">   .user(<span class="string">&quot;请把 &#x27;Hello, World!&#x27; 翻译成法语&quot;</span>)</span><br><span class="line">   .call().content();</span><br></pre></td></tr></table></figure></blockquote>
<ol start="2">
<li><strong>prompt(Prompt prompt)</strong>: 这个方法接受一个 Prompt 对象作为参数，让您可以传入一个已经通过 Prompt 类的非流式 API 创建好的 Prompt 实例。</li>
</ol>
<blockquote>
<ol start="2">
<li>prompt(Prompt prompt): 拿着写好的菜单直接点餐<br> 代码：chatClient.prompt(myPrompt)<br> 比喻：你在来餐厅的路上，就已经用 App 提前把你的菜单（一个 Prompt 对象）编辑好了。到了餐厅，你直接把手机上的菜单二维码给服务员一扫，说：“就照这个单子做！”<br> 使用场景：当你因为某些原因（比如代码解耦、从其他模块传来等）已经有了一个构建好的、完整的 Prompt 对象时，用这个方法可以最直接地把它交给 ChatClient。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 在别的地方，你已经费心构建好了一个 Prompt 对象</span></span><br><span class="line">&gt;<span class="type">Prompt</span> <span class="variable">myDetailedPrompt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Prompt</span>(...); </span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 现在直接把它扔给 ChatClient</span></span><br><span class="line">&gt;chatClient.prompt(myDetailedPrompt) <span class="comment">// &lt;--- 起点</span></span><br><span class="line">   .call().content();</span><br></pre></td></tr></table></figure></blockquote>
<ol start="3">
<li><strong>prompt(String content)</strong>: 这是一个类似于上一个重载方法的便捷方法。它直接接受用户的文本内容。</li>
</ol>
<blockquote>
<p>代码：chatClient.prompt(“你好吗？”)<br>比喻：你赶时间，直接对服务员喊：“来一份最简单的单人套餐！”（这里的套餐内容就是你提供的那段字符串）。<br>使用场景：这是最简单、最便捷的方式，专门用于那种“只有一个用户问题，没有其他任何要求”的场景。它在内部会自动帮你把这个字符串包装成一个只包含单条用户消息的 Prompt 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 背后相当于 chatClient.prompt().user(&quot;你好吗？&quot;)</span></span><br><span class="line">chatClient.prompt(<span class="string">&quot;你好吗？&quot;</span>) <span class="comment">// &lt;--- 起点</span></span><br><span class="line">    .call().content();</span><br></pre></td></tr></table></figure></blockquote>
<h2 id="ChatClient-响应-ChatClient-Responses"><a href="#ChatClient-响应-ChatClient-Responses" class="headerlink" title="ChatClient 响应 (ChatClient Responses)"></a>ChatClient 响应 (ChatClient Responses)</h2><p>ChatClient API 通过其流式 API 提供了多种方式来格式化来自 AI 模型的响应。</p>
<blockquote>
<p>解读：当用户调用 AI 模型后（通过 .call() 或 .stream()），ChatClient 不仅仅是给用户一个简单的字符串。它提供了一套丰富的“工具”，让用户能以不同的形式提取和转换 AI 的响应结果。</p>
</blockquote>
<h3 id="返回一个-ChatResponse"><a href="#返回一个-ChatResponse" class="headerlink" title="返回一个 ChatResponse"></a>返回一个 ChatResponse</h3><p>来自 AI 模型的响应是一个由 ChatResponse 类型定义的丰富结构。它包含了关于响应是如何生成的元数据 (metadata)，并且还可以包含多个被称为 Generations 的响应结果，每个结果都有其自己的元数据。这些元数据包含了用于创建响应的令牌（token）数量（每个 token 大约相当于 3&#x2F;4 个单词）。这个信息很重要，因为托管的 AI 模型是根据每次请求使用的 token 数量来收费的。<br>下面展示了一个示例，通过在 call() 方法后调用 chatResponse() 来返回包含元数据的 ChatResponse 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChatResponse</span> <span class="variable">chatResponse</span> <span class="operator">=</span> chatClient.prompt()</span><br><span class="line">    .user(<span class="string">&quot;Tell me a joke&quot;</span>)</span><br><span class="line">    .call()</span><br><span class="line">    .chatResponse();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解读：AI 的响应远不止一串文本那么简单。它是一个包含丰富“附加信息”的复杂对象，而 .chatResponse() 方法就是获取这个完整对象的钥匙。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回类型</th>
<th>用途</th>
<th>比喻</th>
</tr>
</thead>
<tbody><tr>
<td>.content()</td>
<td>String</td>
<td>只想要核心文本内容，简单快捷</td>
<td>只看电影正片</td>
</tr>
<tr>
<td>.chatResponse()</td>
<td>ChatResponse</td>
<td>想要全部，包括元数据、Token 消耗等</td>
<td>看蓝光典藏版影碟</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="返回一个实体-Entity"><a href="#返回一个实体-Entity" class="headerlink" title="返回一个实体 (Entity)"></a>返回一个实体 (Entity)</h3><p>您通常希望返回一个从返回的字符串映射而来的实体类。entity() 方法提供了此功能。</p>
<p>例如，给定以下 Java record：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">ActorFilms</span><span class="params">(String actor, List&lt;String&gt; movies)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>您可以使用 entity() 方法轻松地将 AI 模型的输出映射到这个 record，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ActorFilms</span> <span class="variable">actorFilms</span> <span class="operator">=</span> chatClient.prompt()</span><br><span class="line">    .user(<span class="string">&quot;生成一个随机演员的电影作品列表。&quot;</span>)</span><br><span class="line">    .call()</span><br><span class="line">    .entity(ActorFilms.class);</span><br></pre></td></tr></table></figure>

<p>此外，还有一个重载的 entity 方法，其签名为 entity(ParameterizedTypeReference<T> type)，它允许您指定泛型类型，例如泛型列表 List：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ActorFilms&gt; actorFilms = chatClient.prompt()</span><br><span class="line">    .user(<span class="string">&quot;生成汤姆·汉克斯和比尔·默瑞的电影作品列表&quot;</span>)</span><br><span class="line">    .call()</span><br><span class="line">    .entity(<span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ActorFilms&gt;&gt;() &#123;&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解读：</p>
<p>核心就是：<strong>不要再手动解析 AI 返回的 JSON 字符串了！Spring AI 可以自动帮你把 AI 的文本回答直接转换成你想要的 Java 对象。</strong></p>
<p><strong>比喻：手动翻译 vs. 同声传译</strong></p>
<ul>
<li><strong>传统方式 (手动解析):</strong></li>
</ul>
<ol>
<li>你告诉 AI：“请用 JSON 格式返回演员汤姆·汉克斯的电影列表。”</li>
<li>AI 返回给你一长串文本：”{&quot;actor&quot;:&quot;Tom Hanks&quot;,&quot;movies&quot;:[&quot;Forrest Gump&quot;,&quot;Saving Private Ryan&quot;]}”</li>
<li>你拿到这个字符串后，需要自己找一个 JSON 解析库（比如 Jackson 或 Gson），写一堆代码（objectMapper.readValue(…)）来把它手动转换成你的 ActorFilms Java 对象。</li>
<li>这就像：你听到一段外语，需要先用笔把它逐字记下来，然后再查字典一个词一个词地翻译。过程繁琐且容易出错。</li>
</ol>
<ul>
<li><strong>Spring AI 的 .entity() 方式 (结构化输出)：</strong></li>
</ul>
<ol>
<li>你用同样的方式告诉 AI 你想要什么。</li>
<li>然后你直接在调用链的末尾加上 .entity(ActorFilms.class)。</li>
<li>Spring AI 在背后默默地帮你完成了所有工作：</li>
</ol>
<ul>
<li><ul>
<li>它会优化你的 prompt，确保 AI 更大概率返回正确的 JSON 格式。</li>
</ul>
</li>
<li><ul>
<li>它拿到 AI 返回的文本。</li>
<li>它自动调用内置的 JSON 解析器，将文本转换成你指定的 ActorFilms.class 实例。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>你直接就得到了一个类型安全、立即可用的 Java 对象！</li>
<li>这就像：你戴上了一副同声传译耳机。你听到外语的同时，耳机里已经传来了翻译好的母语。过程无缝、高效、无需动手。</li>
</ol>
<p><strong>两种 entity() 方法的用法</strong></p>
<ol>
<li>entity(Class<T> type): 用于简单的、非泛型的对象</li>
</ol>
<ul>
<li><ul>
<li>代码: .entity(ActorFilms.class)</li>
</ul>
</li>
<li><ul>
<li><p>何时使用: 当你期望的结果是一个单一的、具体的类的实例时，比如 ActorFilms、User、Product。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个简单的 Java 对象 (用 record 更简洁)</span></span><br><span class="line"><span class="keyword">record</span> <span class="title class_">ActorFilms</span><span class="params">(String actor, List&lt;String&gt; movies)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起调用并直接获取对象</span></span><br><span class="line"><span class="type">ActorFilms</span> <span class="variable">actorFilms</span> <span class="operator">=</span> chatClient.prompt()</span><br><span class="line">    .user(<span class="string">&quot;为随机一位演员生成电影作品列表。&quot;</span>)</span><br><span class="line">    .call()</span><br><span class="line">    .entity(ActorFilms.class); <span class="comment">// &lt;-- 直接指定类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在可以直接使用 actorFilms 对象了</span></span><br><span class="line">System.out.println(<span class="string">&quot;演员: &quot;</span> + actorFilms.actor());</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ol start="2">
<li>entity(ParameterizedTypeReference<T> type): 用于复杂的、带泛型的对象</li>
</ol>
<ul>
<li><ul>
<li>代码: .entity(new ParameterizedTypeReference&lt;List<ActorFilms>&gt;() {})</li>
</ul>
</li>
<li><ul>
<li><p>为何需要这么复杂? 因为 Java 的泛型有类型擦除的特性。在运行时，List<ActorFilms> 和 List<String> 都会被“擦除”成同一个 List.class。只传入 List.class，程序就不知道列表里面应该装什么类型的对象。ParameterizedTypeReference 是 Spring 提供的一种“技巧”，它能在运行时保留并传递完整的泛型信息（“我想要的不仅是个 List，而是个装满了 ActorFilms 的 List”）。</p>
</li>
<li><p>何时使用: 当你期望的结果是一个泛型集合时，最常见的就是 List<T>、Map&lt;K, V&gt; 等。</p>
</li>
<li><p>示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标是获取一个 ActorFilms 对象的列表</span></span><br><span class="line">List&lt;ActorFilms&gt; actorFilmsList = chatClient.prompt()</span><br><span class="line">    .user(<span class="string">&quot;为汤姆·汉克斯和比尔·默里各生成5部电影的作品列表。&quot;</span>)</span><br><span class="line">    .call()</span><br><span class="line">    .entity(<span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ActorFilms&gt;&gt;() &#123;&#125;); <span class="comment">// &lt;-- 保留泛型信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在可以直接遍历这个列表了</span></span><br><span class="line"><span class="keyword">for</span> (ActorFilms af : actorFilmsList) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;演员: &quot;</span> + af.actor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
<th>关键点</th>
</tr>
</thead>
<tbody><tr>
<td>.entity(YourClass.class)</td>
<td>将 AI 响应映射到单个普通 Java 对象。</td>
<td>简单直接，适用于非泛型类。</td>
</tr>
<tr>
<td>.entity(new ParameterizedTypeReference&lt;…&gt;() {})</td>
<td>将 AI 响应映射到泛型集合（如 List）。</td>
<td>解决了 Java 泛型擦除问题，必须用这种写法。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<p><strong>.entity() 是 Spring AI 的“杀手级”功能之一。它将大语言模型的非结构化文本输出，与 Java 的强类型、结构化编程世界无缝地连接了起来，是构建健壮、可靠 AI 应用的基石。</strong></p>
</blockquote>
<h3 id="流式响应-Streaming-Responses"><a href="#流式响应-Streaming-Responses" class="headerlink" title="流式响应 (Streaming Responses)"></a>流式响应 (Streaming Responses)</h3><p>stream() 方法让您能够获得一个异步的响应，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; output = chatClient.prompt()</span><br><span class="line">    .user(<span class="string">&quot;Tell me a joke&quot;</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .content();</span><br></pre></td></tr></table></figure>

<p>您也可以使用 Flux<ChatResponse> chatResponse() 方法来流式地获取 ChatResponse。</p>
<p>未来，我们将提供一个便捷的方法，让您可以通过响应式的 stream() 方法直接返回一个 Java 实体。在此期间，您应该使用<strong>结构化输出转换器 (Structured Output Converter)</strong> 来显式地转换聚合后的响应，如下所示。这也演示了在流式 API 中使用参数的方法，这将在文档的后续部分进行更详细的讨论。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 BeanOutputConverter，指定期望的输出类型</span></span><br><span class="line"><span class="type">var</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanOutputConverter</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ActorsFilms&gt;&gt;() &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起流式请求</span></span><br><span class="line">Flux&lt;String&gt; flux = <span class="built_in">this</span>.chatClient.prompt()</span><br><span class="line">    .user(u -&gt; u.text(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                        Generate the filmography for a random actor.</span></span><br><span class="line"><span class="string">                        &#123;format&#125;</span></span><br><span class="line"><span class="string">                      &quot;&quot;&quot;</span>)</span><br><span class="line">            .param(<span class="string">&quot;format&quot;</span>, <span class="built_in">this</span>.converter.getFormat()))</span><br><span class="line">    .stream()</span><br><span class="line">    .content();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集所有流式返回的字符串片段并合并成一个完整的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="built_in">this</span>.flux.collectList().block().stream().collect(Collectors.joining());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用转换器手动将完整的字符串内容转换为 Java 对象列表</span></span><br><span class="line">List&lt;ActorFilms&gt; actorFilms = <span class="built_in">this</span>.converter.convert(<span class="built_in">this</span>.content);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解读：</p>
<p>这段话的核心是告诉你如何处理像 ChatGPT 网站上那种“一个词一个词往外蹦”的响应效果，并点出了当前在流式场景下获取结构化数据（Java 对象）的临时解决方案。</p>
<ol>
<li><strong>什么是流式响应？ (stream())</strong></li>
</ol>
<ul>
<li><ul>
<li><strong>.call() (同步)</strong>：你问问题，然后<strong>一直等</strong>，直到 AI 把<strong>完整</strong>的一大段话说完，你才收到所有内容。</li>
<li><strong>.stream() (流式&#x2F;异步)</strong>：你问问题，AI <strong>一边想一边说</strong>。它每想出一个词或一小段话，就立刻发给你。你收到的是一个持续不断的数据流，而不是一次性的完整结果。</li>
<li><strong>返回类型 Flux<T></strong>：stream() 方法返回的是一个 Flux 对象。Flux 是 Project Reactor (Spring 的响应式编程库) 中的一个核心类型，代表一个可以发出 0 到 N 个元素的<strong>异步序列（数据流）</strong>。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p><strong>简单的流式文本 (.stream().content())</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; output = chatClient.prompt()</span><br><span class="line">    .user(<span class="string">&quot;Tell me a joke&quot;</span>)</span><br><span class="line">    .stream()  <span class="comment">// &lt;-- 关键：从这里开始，一切都是异步的、流式的</span></span><br><span class="line">    .content(); <span class="comment">// &lt;-- 从流中的每个小块（Chunk）里提取文本内容</span></span><br></pre></td></tr></table></figure>

<ul>
<li>工作流程:</li>
<li><ul>
<li>.stream() 发起请求，但不会阻塞，而是立即返回一个 Flux<String>。</li>
</ul>
</li>
<li><ul>
<li>AI 模型开始生成响应，比如 “Why”, “ did”, “ the”, “ scarecrow”, “ win”, “ an”, “ award?”</li>
</ul>
</li>
<li><ul>
<li>Flux 会依次发出这些字符串片段。</li>
</ul>
</li>
<li><ul>
<li>你可以“订阅”(subscribe) 这个 Flux 来处理每一个到来的片段，例如在界面上实时显示它们，实现打字机效果。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>流式场景下的结构化输出 (一个当前的“权宜之计”)</strong></p>
<p>这是本段最复杂也最重要的部分。</p>
<ul>
<li><p>问题所在: .entity() 这个便捷的方法在 stream() 模式下尚不可用（原文说“未来会提供”）。你不能直接 .stream().entity(…)。因为流是一个个碎片，你无法在收到第一个碎片时就把它转换成一个完整的 Java 对象。</p>
</li>
<li><p><strong>当前的解决方案: 分三步走:</strong></p>
<ol>
<li><p><strong>准备工作：创建转换器并修改 Prompt</strong></p>
<ol>
<li><p>-var converter &#x3D; new BeanOutputConverter&lt;&gt;(…)：手动创建一个“转换器”，告诉它你最终想要什么类型的 Java 对象（比如 List<ActorFilms>）。</p>
</li>
<li><p>.param(“format”, this.converter.getFormat())：最关键的一步！这个转换器内部有一个 getFormat() 方法，它能生成一段特殊的指令文本，告诉 AI “请务必以我指定的 JSON 格式返回你的答案”。你必须把这个指令作为参数塞进你的 prompt 里。</p>
</li>
</ol>
</li>
<li><p><strong>执行与收集：发起流式请求，并把所有碎片重新拼起来</strong></p>
</li>
<li><p>chatClient.prompt(…).stream().content()：像之前一样，获取一个包含 JSON 字符串碎片的 Flux。</p>
</li>
<li><p>flux.collectList().block()…：这是一个响应式编程的操作。</p>
<ol>
<li>collectList(): “把流里的所有碎片都收集起来，放到一个列表里。”</li>
<li>.block(): “一直等，直到所有碎片都收集完毕。”（这里把异步操作又变回了同步等待，因为你需要完整的 JSON 才能解析）。</li>
<li>.stream().collect(Collectors.joining()): 把列表里的所有字符串碎片无缝拼接成一个完整的 JSON 字符串。</li>
</ol>
</li>
</ol>
</li>
<li><ol start="3">
<li><strong>手动转换：使用转换器完成最后一步</strong></li>
</ol>
<ul>
<li><ul>
<li>List<ActorFilms> actorFilms &#x3D; this.converter.convert(this.content);</li>
<li>现在你有了完整的 JSON 字符串 content，最后调用转换器的 convert 方法，手动完成从字符串到 Java 对象的转换。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>场景</th>
<th>方法链</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>获取流式文本</td>
<td>.stream().content()</td>
<td>简单直接，获取 Flux<String>，用于实现打字机效果。</td>
</tr>
<tr>
<td>获取流式结构化对象 (当前)</td>
<td>(复杂三步法)</td>
<td>1. 创建 Converter 并修改 Prompt。<br>2. .stream() 后收集并拼接成完整字符串。<br>3. 手动调用 converter.convert()。</td>
</tr>
</tbody></table>
<p>虽然 Spring AI 的目标是让一切都简单，但在某些功能（如流式结构化输出）尚未完全成熟时，它也为你提供了底层的、稍微复杂一些的手动工具 (BeanOutputConverter) 作为过渡方案。</p>
</blockquote>
<h2 id="提示模板-Prompt-Templates"><a href="#提示模板-Prompt-Templates" class="headerlink" title="提示模板 (Prompt Templates)"></a>提示模板 (Prompt Templates)</h2><blockquote>
<p>前情提要：</p>
<p>什么是提示模板？为什么需要它？</p>
<ul>
<li><p>没有模板 (硬编码)：</p>
<p>“Tell me a joke about a cat.”<br>如果你想问关于狗的笑话，你得重写整个字符串。</p>
</li>
<li><p>使用模板：<br>“Tell me a joke about a {topic}.”<br>这是一个可复用的模板。你可以保持模板不变，只在运行时改变 {topic} 的值（比如 “cat”, “dog”, “programmer”），就能生成不同的提示。</p>
</li>
</ul>
</blockquote>
<p>ChatClient 流式 API 允许您将用户和系统的文本作为带有变量的模板来提供，这些变量会在运行时被替换。</p>
<blockquote>
<p>这段话的核心是告诉你：<strong>不要把你的提示写死！Spring AI 内置了一个强大的模板引擎，让你可以在提示中预留“坑位”（占位符），然后在运行时动态地填入内容。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">answer</span> <span class="operator">=</span> ChatClient.create(chatModel).prompt()</span><br><span class="line">    .user(u -&gt; u</span><br><span class="line">    		<span class="comment">// 1. 在 .text() 方法中，用 &#123;占位符&#125; 的形式定义你的模板</span></span><br><span class="line">            .text(<span class="string">&quot;Tell me the names of 5 movies whose soundtrack was composed by &#123;composer&#125;&quot;</span>)</span><br><span class="line">          	<span class="comment">// 2. 使用 .param() 方法，为同名的占位符提供具体的值</span></span><br><span class="line">            .param(<span class="string">&quot;composer&quot;</span>, <span class="string">&quot;John Williams&quot;</span>))</span><br><span class="line">    .call()</span><br><span class="line">    .content();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>.text(): 定义模板字符串。<br>.param(“key”, “value”): 为模板中名为 key 的占位符填充 value。</p>
<p>在发送给 AI 之前，Spring AI 会自动把它们拼接成最终的提示：”Tell me the names of 5 movies whose soundtrack was composed by John Williams”。</p>
</blockquote>
<p>在内部，ChatClient 使用 PromptTemplate 类来处理用户和系统的文本，并依赖一个给定的 TemplateRenderer 实现来用运行时提供的值替换变量。默认情况下，Spring AI 使用 StTemplateRenderer 实现，它基于由 Terence Parr 开发的开源 StringTemplate 引擎。</p>
<blockquote>
<ul>
<li>PromptTemplate: Spring AI 内部用来表示一个“模板化提示”的对象。</li>
<li>TemplateRenderer: 这是**“渲染器”或“模板引擎”**的接口。它的工作就是接收一个带占位符的模板和一堆参数，然后输出最终的、被填充好的字符串。</li>
<li>StTemplateRenderer: 这是 Spring AI 默认的渲染器实现。它背后使用的是一个叫 StringTemplate 的成熟、强大的开源库。</li>
</ul>
<blockquote>
<p>默认情况下，无需关心这些内部实现，Spring AI 会自动用 StringTemplate 帮你处理 {…} 格式的占位符。</p>
</blockquote>
</blockquote>
<p>Spring AI 也提供了一个 NoOpTemplateRenderer，用于不需要任何模板处理的情况。</p>
<blockquote>
<p>直接在 ChatClient 上配置的 TemplateRenderer (通过 .templateRenderer()) 仅适用于直接在 ChatClient 构建器链中定义的提示内容（例如，通过 .user(), .system()）。它不影响像 QuestionAnswerAdvisor 这样的“顾问”(Advisors) 内部使用的模板，这些顾问有它们自己的模板定制机制（请参阅“自定义顾问模板”）。</p>
</blockquote>
<p>如果您倾向于使用不同的模板引擎，您可以直接向 ChatClient 提供一个自定义的 TemplateRenderer 接口实现。您也可以继续使用默认的 StTemplateRenderer，但使用自定义的配置。</p>
<blockquote>
<p>这里提到了两种常见的定制需求：</p>
<ul>
<li>a) 根本不想要模板功能</li>
</ul>
<p> **场景：**你的提示内容本身就包含 {}，比如你正在向 AI 提问关于 Java 泛型或 JSON 的问题。默认的模板引擎可能会误以为这些是占位符，从而导致错误。<br> **解决方案：**使用 NoOpTemplateRenderer。NoOp 是 “No Operation” 的缩写，意思是“啥也别干”。这个渲染器会原封不动地返回你的文本，不做任何替换。</p>
<ul>
<li>b) 更换占位符的分隔符</li>
</ul>
<p> **场景：**和上面类似，为了避免 {} 与你的提示内容（特别是 JSON）冲突，你想换一种更安全的分隔符，比如 &lt;…&gt;。<br> **解决方案：**你可以不更换整个引擎，而是重新配置默认的 StTemplateRenderer。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.templateRenderer( <span class="comment">// 告诉 ChatClient：“别用默认的渲染器了，用我这个定制版的！”</span></span><br><span class="line">    StTemplateRenderer.builder() <span class="comment">// 获取一个 StTemplateRenderer 的建造者</span></span><br><span class="line">        .startDelimiterToken(<span class="string">&#x27;&lt;&#x27;</span>) <span class="comment">// 把开始符号从 &#x27;&#123;&#x27; 改成 &#x27;&lt;&#x27;</span></span><br><span class="line">        .endDelimiterToken(<span class="string">&#x27;&gt;&#x27;</span>)   <span class="comment">// 把结束符号从 &#x27;&#125;&#x27; 改成 &#x27;&gt;&#x27;</span></span><br><span class="line">        .build() <span class="comment">// 创建这个定制版的渲染器实例</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p> <strong>重要提示: 当你这么做之后，你的模板文本也必须同步修改，把 { composer } 改成 &lt; composer &gt;。</strong></p>
</blockquote>
<blockquote>
<p><strong>.templateRenderer() 仅适用于直接在 ChatClient 构建器链中定义的提示内容…</strong></p>
<p>**这句话的意思是：**你在一次调用中通过 .templateRenderer() 设置的渲染器，只对这一次调用生效。它是一个局部的、一次性的配置。<br><strong>它不会影响更高级的、封装了自身逻辑的组件（比如 QuestionAnswerAdvisor，即 RAG 的核心组件）。那些组件有自己独立的模板配置方式，因为它们的模板通常更复杂。</strong></p>
</blockquote>
<p>例如，默认情况下，模板变量是通过 {} 语法来识别的。如果您计划在提示中包含 JSON，您可能想要使用不同的语法以避免与 JSON 语法冲突。例如，您可以使用 &lt; 和 &gt; 作为定界符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">answer</span> <span class="operator">=</span> ChatClient.create(chatModel).prompt()</span><br><span class="line">    .user(u -&gt; u	</span><br><span class="line">            .text(<span class="string">&quot;Tell me the names of 5 movies whose soundtrack was composed by &lt;composer&gt;&quot;</span>)</span><br><span class="line">            .param(<span class="string">&quot;composer&quot;</span>, <span class="string">&quot;John Williams&quot;</span>))</span><br><span class="line"> .templateRenderer(StTemplateRenderer.builder().startDelimiterToken(<span class="string">&#x27;&lt;&#x27;</span>).endDelimiterToken(<span class="string">&#x27;&gt;&#x27;</span>).build())</span><br><span class="line">    .call()</span><br><span class="line">    .content();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>小总结:</strong></p>
<ul>
<li><p><strong>基础用法:</strong> 使用 {} 作为占位符，并通过 .param() 方法传值，实现动态提示。</p>
</li>
<li><p><strong>核心原理:</strong> 背后由 StringTemplate 引擎驱动。</p>
</li>
<li><p><strong>高级定制:</strong></p>
<p>可以通过 .templateRenderer() 在单次调用中更换渲染器。<br>可以换成 NoOpTemplateRenderer 来禁用模板功能。<br>可以重新配置默认的 StTemplateRenderer 来更换分隔符（比如 &lt;…&gt;），以避免与 JSON 等语法冲突。</p>
</li>
</ul>
</blockquote>
<h2 id="call-的返回值-call-return-values"><a href="#call-的返回值-call-return-values" class="headerlink" title=".call() 的返回值(call() return values)"></a>.call() 的返回值(call() return values)</h2><p>在 ChatClient 上指定 call() 方法后，对于响应类型，有几种不同的选项。</p>
<blockquote>
<p>这段话的核心是：在发起同步调用 .call() 之后，Spring AI 为你提供了多条“取货通道”，你可以根据自己的需求，选择最合适的那一条来获取 AI 的响应。</p>
</blockquote>
<blockquote>
<p>我们用一个“去餐厅吃饭”的比喻来梳理这些选项，假设你已经点完餐（.prompt()）并告诉服务员“可以上菜了”（.call()）。现在，你要决定如何“享用”这顿饭。</p>
</blockquote>
<ul>
<li><p>String content(): 返回响应的 String 内容。</p>
<blockquote>
<p>content():只吃主菜</p>
<p>比喻：你对服务员说：“别的都别管，直接把主菜（比如牛排）端上来就行！”<br>返回：String<br>用途：最简单、最常用。当你只关心 AI 回答的核心文本内容时，用这个就够了。</p>
</blockquote>
</li>
<li><p>ChatResponse chatResponse(): 返回 ChatResponse 对象，该对象包含多个生成结果（Generations）以及关于响应的元数据，例如用于创建该响应的 token 数量。</p>
<blockquote>
<p>chatResponse(): 不仅吃主菜，还要看菜单和账单<br>比喻：你对服务员说：“把主菜端上来，顺便把详细的菜单（包含成分说明）和本次消费的账单（Token 使用量）也一起拿来。”<br>返回：ChatResponse<br>用途：当你需要监控成本（看 token）、调试问题（看元数据）、或处理 AI 返回的多个候选答案时使用。</p>
</blockquote>
</li>
<li><p>ChatClientResponse chatClientResponse(): 返回一个 ChatClientResponse 对象，该对象包含 ChatResponse 对象和 ChatClient 的执行上下文，让您能够访问在“顾问”(Advisors) 执行期间使用的附加数据（例如，在 RAG 流程中检索到的相关文档）。</p>
<blockquote>
<p>chatClientResponse(): 不仅要菜和账单，还要知道厨师是谁、采购员从哪买的菜<br>比喻：你对服务员说：“除了菜和账单，我还要知道这道菜是哪个厨师团队（Advisor）做的，他们为了做这道菜，特意去哪个市场采购了哪些新鲜食材（RAG 检索到的文档）。”<br>返回：ChatClientResponse<br>用途：这是一个非常高级的选项。当你使用了更复杂的 Spring AI 组件，比如 QuestionAnswerAdvisor (RAG的核心)，并且你需要获取这些组件在执行过程中的内部数据（比如 RAG 到底引用了哪些文档来生成答案）时，才会用到它。普通用例几乎接触不到。</p>
</blockquote>
</li>
<li><p>entity() 用于返回一个 Java 类型:</p>
<p>entity(ParameterizedTypeReference<T> type): 用于返回一个实体类型的集合（Collection）。<br>entity(Class<T> type): 用于返回一个特定的实体类型。<br>entity(StructuredOutputConverter<T> structuredOutputConverter): 用于指定一个 StructuredOutputConverter 的实例，以将字符串转换为实体类型。</p>
<blockquote>
<p>entity(…): 让服务员把菜按我要求摆盘<br>这是结构化输出的功能，它有几种不同的“摆盘”方式：</p>
<ul>
<li><p>entity(ParameterizedTypeReference&lt; T &gt; type): 按家庭分享餐摆盘</p>
<p>比喻：“请把菜摆成一个‘家庭分享餐’（List&lt; ActorFilms &gt;）的样子，里面要有多份单人套餐。”<br>用途：将 AI 响应转换成一个泛型集合，比如 List&lt; YourClass &gt;。</p>
</li>
<li><p>entity(Class&lt; T &gt; type): 按单人套餐摆盘</p>
<p>比喻：“请把菜直接摆成一个‘单人套餐’（ActorFilms 对象）的样子给我。”<br>用途：将 AI 响应直接转换成一个普通的 Java 对象。</p>
</li>
<li><p>entity(StructuredOutputConverter&lt; T &gt; structuredOutputConverter): 按我自带的图纸摆盘</p>
<p>比喻：“别用你们餐厅的盘子了，用我自带的这个设计图纸（StructuredOutputConverter 实例）来摆盘。”<br>用途：这是一个更底层的定制选项。当你有一个自己创建或配置的转换器实例时，可以用它来指导转换过程。这在使用流式API处理结构化输出时见过。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<p>您也可以调用 stream() 方法来替代 call()。</p>
<blockquote>
<p>最后，别忘了，所有这些都是在 .call()（同步）之后使用的。如果你想用异步流式的方式，那就得把 .call() 换成 .stream()，然后使用流式 API 提供的对应方法。</p>
</blockquote>
<h2 id="stream-的返回值-stream-return-values"><a href="#stream-的返回值-stream-return-values" class="headerlink" title=".stream() 的返回值(stream() return values)"></a>.stream() 的返回值(stream() return values)</h2><p>在 ChatClient 上指定 stream() 方法后，对于响应类型，有几个选项：</p>
<blockquote>
<p>.stream() 方法把 .call() 的所有返回类型都装进了一个叫 Flux 的“异步管道”里。你不再是一次性收到一个完整的结果，而是会通过这个管道，持续不断地收到一个个数据块。</p>
</blockquote>
<blockquote>
<p>我们继续用“去餐厅吃饭”的比喻，但这次，餐厅的服务模式升级了，变成了“回转寿司”。你坐在传送带旁边，菜品会一片一片、一盘一盘地传送到你面前。</p>
</blockquote>
<ul>
<li><p>Flux&lt; String &gt; content(): 返回一个 Flux，该 Flux 会持续发出由 AI 模型正在生成的字符串片段。</p>
<blockquote>
<p>content(): 只拿传送带上的寿司肉<br>返回: Flux&lt; String &gt;<br>比喻: 传送带上源源不断地传来一小片一小片的生鱼片（字符串片段）。你只关心吃肉，所以你只拿这些鱼片。比如，AI 的回答是 “Hello World”，传送带可能会依次传来 “He”, “llo”, “ Wo”, “rld”。<br>用途: 实现打字机效果。这是最常见的流式用例。你“订阅”(subscribe) 这个 Flux&lt; String &gt;，每当一小段文本传来，你就在界面上把它追加显示出来。</p>
</blockquote>
</li>
<li><p>Flux&lt; ChatResponse &gt; chatResponse(): 返回一个 Flux，该 Flux 会发出 ChatResponse 对象，其中包含了关于响应的附加元数据。</p>
<blockquote>
<p>chatResponse(): 传送带上不仅有寿司，还有带说明的小盘子</p>
<p> 返回: Flux&lt; ChatResponse &gt;</p>
<p> 比喻: 传送带上传来的不再是裸露的鱼片，而是一小盘一小盘的寿司。每个盘子（ChatResponse）上不仅有寿司（文本片段），还可能贴着标签，写着“这是今天第一批金枪鱼”、“这批的 token 消耗是 5”等等（元数据）。<br> 用途: 当你需要在流式处理的过程中，实时获取每一小块响应的元数据时使用。比如，你可能想在流结束时，累加所有中间过程的 token 消耗。这比等到最后才拿到总的 ChatResponse 要更实时。</p>
</blockquote>
</li>
<li><p>Flux&lt; ChatClientResponse &gt; chatClientResponse(): 返回一个 Flux，该 Flux 会发出 ChatClientResponse 对象，该对象包含 ChatResponse 对象和 ChatClient 的执行上下文，让您能够访问在“顾问”(Advisors) 执行期间使用的附加数据（例如，在 RAG 流程中检索到的相关文档）。</p>
<blockquote>
<p>chatClientResponse(): 传送带上不仅有盘子，还有厨师的签名和采购记录<br>返回: Flux<ChatClientResponse><br>比喻: 传送带上传来的盘子更加豪华了。除了寿司和标签，盘子底下还附带了一张卡片，上面有主厨（Advisor）的签名，以及这张卡片所用的鱼是今天早上从哪个码头（RAG 检索到的文档）采购的记录。<br>用途: 非常高级且罕见。用于在流式 RAG 场景下，实时地想知道“当前生成的这段话，是参考了哪些文档片段”。这可以用来在界面上实现一种效果：当 AI 的回答逐渐出现时，旁边同步高亮显示它正在参考的原文。</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th>同步 (call()) 之后</th>
<th>异步 (stream()) 之后</th>
<th>区别是什么？</th>
</tr>
</thead>
<tbody><tr>
<td>.content() -&gt; String</td>
<td>.content() -&gt; Flux&lt; String &gt;</td>
<td>一次性拿到完整字符串 vs. 通过管道持续收到字符串片段。</td>
</tr>
<tr>
<td>.chatResponse() -&gt; ChatResponse</td>
<td>.chatResponse() -&gt; Flux&lt; ChatResponse &gt;</td>
<td>一次性拿到完整的带元数据的响应 vs. 通过管道持续收到带元数据的响应片段。</td>
</tr>
<tr>
<td>.chatClientResponse() -&gt; ChatClientResponse</td>
<td>.chatClientResponse() -&gt; Flux&lt; ChatClientResponse &gt;</td>
<td>一次性拿到完整的带执行上下文的响应 vs. 通过管道持续收到带上下文的响应片段。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>关键记忆点：.stream() 只是把 .call() 的所有返回结果，都用 Flux&lt;…&gt; 这个异步管道包装了起来。选择哪个，取决于你是想“等所有菜都上齐了再吃”（同步 call），还是想“菜上来一道吃一道”（异步 stream）。</strong></p>
</blockquote>
<h2 id="Using-Defaults-使用默认值"><a href="#Using-Defaults-使用默认值" class="headerlink" title="Using Defaults(使用默认值)"></a>Using Defaults(使用默认值)</h2><p>在一个 @Configuration 类中创建一个带有默认系统文本的 ChatClient，可以简化运行时的代码。通过设置默认值，您在调用 ChatClient 时只需要指定用户文本，从而无需在您的运行时代码路径中为每个请求都设置系统文本。</p>
<blockquote>
<p>这段话的核心思想是：不要在每次对话时都重复告诉 AI 它的“人设”。在应用启动时一次性配置好，以后每次调用时，它就自动带上这个人设了。</p>
</blockquote>
<h3 id="默认系统文本-Default-System-Text"><a href="#默认系统文本-Default-System-Text" class="headerlink" title="默认系统文本 (Default System Text)"></a>默认系统文本 (Default System Text)</h3><p>在下面的示例中，我们将配置系统文本，使其总是以海盗(“You are a friendly chat bot that answers question in the voice of a Pirate”–&gt;”你是一个友好的聊天机器人，要用一个海盗（Pirate）的口吻来回答问题。”)的口吻回复。为了避免在运行时代码中重复设置系统文本，我们将在一个 @Configuration 类中创建一个 ChatClient 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Configuration 注解告诉 Spring：“这个类是专门用来做配置的，请在启动时扫描它。”</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">	<span class="comment">// @Bean 注解告诉 Spring：“请调用这个方法，并把它的返回值作为一个 Bean（一个由 Spring 管理的对象）</span></span><br><span class="line">    <span class="comment">// 放入你的容器中，以便其他地方可以注入使用它。”</span></span><br><span class="line">    <span class="comment">// 这个 Bean 的默认名字就是方法名：&#x27;chatClient&#x27;。</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ChatClient <span class="title function_">chatClient</span><span class="params">(ChatClient.Builder builder)</span> &#123;<span class="comment">// &lt;--- 注入通用的 Builder</span></span><br><span class="line">        <span class="comment">// 使用通用的 Builder 来创建一个【特制版】的 ChatClient</span></span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">            <span class="comment">//  .defaultSystem(...) 是核心！</span></span><br><span class="line">            <span class="comment">// 它为这个即将被创建的 ChatClient 实例设置了一个【默认的系统提示】。</span></span><br><span class="line">            <span class="comment">// 就像给助理设定了默认人设：“你是一个友好的聊天机器人，要用海盗的口吻回答问题。”</span></span><br><span class="line">            .defaultSystem(<span class="string">&quot;You are a friendly chat bot that answers question in the voice of a Pirate&quot;</span>)</span><br><span class="line">                .build();<span class="comment">// 创建并返回这个“海盗版”ChatClient</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>从 Builder 到 Client: 这个 @Bean 方法的输入是通用的 ChatClient.Builder，输出是一个经过定制的、具体的 ChatClient 实例。</li>
<li>@Bean 的魔力: Spring 容器现在有了一个名为 chatClient 的特定 Bean。当其他组件请求注入一个 ChatClient 类型的对象时，Spring 会把这个“海盗版”的实例提供给它。</li>
<li>集中配置: 所有关于“海盗”这个角色的设定，都封装在了 Config 类里，与业务逻辑完全分离。</li>
</ul>
</blockquote>
<p>以及一个用于调用它的 @RestController：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AIController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChatClient chatClient;<span class="comment">// &lt;--- 成员变量</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 构造函数注入。注意看！这里注入的不再是 ChatClient.Builder，</span></span><br><span class="line">    <span class="comment">// 而是我们刚刚在 Config 类里通过 @Bean 定义好的那个【具体的 ChatClient 实例】。</span></span><br><span class="line">    <span class="comment">// Spring 会自动找到那个“海盗版”的 chatClient Bean 并注入进来。</span></span><br><span class="line">    AIController(ChatClient chatClient) &#123;</span><br><span class="line">        <span class="built_in">this</span>.chatClient = chatClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/ai/simple&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">completion</span><span class="params">(<span class="meta">@RequestParam(value = &quot;message&quot;, defaultValue = &quot;Tell me a joke&quot;)</span> String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 看这里的调用链，非常简洁！</span></span><br><span class="line">        <span class="keyword">return</span> Map.of(<span class="string">&quot;completion&quot;</span>, </span><br><span class="line">            <span class="built_in">this</span>.chatClient.prompt()</span><br><span class="line">                .user(message)<span class="comment">// 看这里的调用链，非常简洁！</span></span><br><span class="line">                .call()</span><br><span class="line">                .content()</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 完全不需要再写 .system(&quot;...&quot;) 了，因为注入的 chatClient 已经自带了“海盗”人设。</span></span><br><span class="line">        <span class="comment">// 它在内部会自动把默认的系统提示和这里的用户提示组合起来，再发送给 AI。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>注入的是“成品”，不是“工具”: AIController 直接注入了最终产品 ChatClient，而不是用于构建的工具 ChatClient.Builder。这让 Controller 的职责更单一，它只管使用，不管创建。</li>
<li>运行时代码简化: completion 方法的实现非常干净，只关注核心业务逻辑——获取用户输入并调用 AI。所有关于“角色扮演”的模板代码都被消除了。</li>
<li>结果验证: curl 的返回结果 “To hear some arrr-rated jokes! Arrr, matey!” 完美地证明了这一点。AI 的回答充满了海盗的口吻（”arrr-rated”, “Arrr, matey!”），说明我们设置的默认系统提示确实生效了。</li>
</ul>
</blockquote>
<p>当通过 curl 调用应用程序端点时，结果是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ curl localhost:<span class="number">8080</span>/ai/simple</span><br><span class="line">&#123;<span class="string">&quot;completion&quot;</span>:<span class="string">&quot;Why did the pirate go to the comedy club? To hear some arrr-rated jokes! Arrr, matey!&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结</strong><br>这个例子是理解和应用 Spring AI 依赖注入和集中化配置思想的绝佳范本。</p>
<ul>
<li>分离关注点 (Separation of Concerns)：Config 类负责如何创建和配置 AI 客户端，AIController 类负责如何使用 AI 客户端。两者各司其职。</li>
<li>代码整洁 (Clean Code)：通过将通用配置（如 System Prompt）提取到配置类中，极大地简化了业务代码，使其更易读、更易维护。</li>
<li>依赖注入的力量 (Power of DI)：通过 @Bean 和构造函数注入，Spring 框架像一个智能的管道工，自动地将配置好的“海盗版” ChatClient 连接到了需要它的地方。</li>
</ul>
</blockquote>
<h3 id="带参数的默认系统文本-Default-System-Text-with-parameters"><a href="#带参数的默认系统文本-Default-System-Text-with-parameters" class="headerlink" title="带参数的默认系统文本 (Default System Text with parameters)"></a>带参数的默认系统文本 (Default System Text with parameters)</h3><p>在下面的示例中，我们将在系统文本中使用一个占位符，以便在运行时而不是在设计时指定回答的口吻。</p>
<blockquote>
<p>这个例子的核心思想是：我们可以预设一个“半成品”的人设模板，然后在每次对话时，再动态地填入最关键的那部分信息。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ChatClient <span class="title function_">chatClient</span><span class="params">(ChatClient.Builder builder)</span> &#123;</span><br><span class="line">        <span class="comment">// 注意看！这次的默认系统提示是一个【模板】，而不是一个写死的句子。</span></span><br><span class="line">        <span class="comment">// 我们预留了一个叫 &#123;voice&#125; 的“坑位”。</span></span><br><span class="line">        <span class="keyword">return</span> builder.defaultSystem(<span class="string">&quot;You are a friendly chat bot that answers question in the voice of a &#123;voice&#125;&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>关键变化: defaultSystem 的内容从一个固定的字符串 “…” 变成了包含占位符 {voice} 的模板字符串。</li>
<li>现在我们创建的 ChatClient 不再是“海盗版”，我们可以称之为**“演员版”**。它知道自己需要扮演一个角色，但具体扮演谁，它在等待指令。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AIController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChatClient chatClient;</span><br><span class="line"></span><br><span class="line">    AIController(ChatClient chatClient) &#123;</span><br><span class="line">        <span class="built_in">this</span>.chatClient = chatClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/ai&quot;)</span></span><br><span class="line">    Map&lt;String, String&gt; <span class="title function_">completion</span><span class="params">(<span class="meta">@RequestParam(value = &quot;message&quot;, defaultValue = &quot;Tell me a joke&quot;)</span> String message, String voice)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Map.of(<span class="string">&quot;completion&quot;</span>,</span><br><span class="line">                <span class="built_in">this</span>.chatClient.prompt()</span><br><span class="line">                        .system(sp -&gt; sp.param(<span class="string">&quot;voice&quot;</span>, voice))</span><br><span class="line">                        .user(message)</span><br><span class="line">                        .call()</span><br><span class="line">                        .content());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>.system(…): 这不再是像 .system(“some text”) 那样直接提供一个全新的系统提示。</li>
<li>它的作用是: “我要对默认的系统提示进行补充或修改”。</li>
<li>sp -&gt; …: 这是一个 Lambda 表达式，sp 代表 SystemPromptConfigurer，一个专门用来配置系统提示的工具。</li>
<li>sp.param(“voice”, voice): 这句代码的意思是：“请找到默认系统提示模板里的那个叫 {voice} 的占位符，然后用我从 URL 参数里拿到的 voice 变量的值去填充它。”</li>
</ul>
</blockquote>
<p>当通过 httpie 调用应用程序端点时，结果是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http localhost:<span class="number">8080</span>/ai voice==<span class="string">&#x27;Robert DeNiro&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;completion&quot;</span>: <span class="string">&quot;You talkin&#x27; to me? Okay, here&#x27;s a joke for ya: Why couldn&#x27;t the bicycle stand up by itself? Because it was two tired! Classic, right?&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>【完整流程】</strong></p>
<ul>
<li>用户访问 …&#x2F;ai?voice&#x3D;Robert DeNiro。</li>
<li>AIController 接收到请求，voice 变量的值是 “Robert DeNiro”。</li>
<li>.system(sp -&gt; sp.param(“voice”, voice)) 这行代码执行，它把 “Robert DeNiro” 填入到了默认模板 “You are a friendly chat bot that answers question in the voice of a {voice}” 中。</li>
<li>最终，发送给 AI 的实际系统提示变成了：”You are a friendly chat bot that answers question in the voice of a Robert DeNiro”。</li>
<li>AI 接收到这个指令，开始模仿著名演员罗伯特·德尼罗的经典台词（”You talkin’ to me?”）来回答问题。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>总结</strong><br>这个例子展示了一个非常强大和实用的模式：</p>
<ul>
<li>在配置层 (@Configuration)：定义一个通用的、带占位符的默认模板，设定好框架。</li>
<li>在业务层 (@RestController)：只关注填充模板中的动态部分，而不需要重复整个模板的框架。</li>
</ul>
<p>这种方式兼顾了代码的简洁性和运行时的灵活性。你可以用同样的代码，通过改变 voice 参数，让 AI 模仿海盗、莎士比亚、牛仔、宇航员……而无需修改一行后端代码。这是构建高度可定制化 AI 应用的关键技巧。</p>
</blockquote>
<h3 id="其他默认值-Other-defaults"><a href="#其他默认值-Other-defaults" class="headerlink" title="其他默认值 (Other defaults)"></a>其他默认值 (Other defaults)</h3><p>在 ChatClient.Builder 级别，您可以指定默认的提示配置。</p>
<blockquote>
<p>ChatClient.Builder 是一个强大的“预设工作台”。你不仅可以预设系统提示（人设），还可以预设模型参数、可用工具、默认问题、甚至是 RAG 功能。</p>
<p>我们可以把 ChatClient 想象成一个高度定制的“智能助理机器人”。通过 Builder 的 defaultXxx() 系列方法，你可以在它出厂前（build() 之前）为它安装各种“默认配件”和“默认程序”。</p>
</blockquote>
<ul>
<li><p>defaultOptions(ChatOptions chatOptions): 传入定义在 ChatOptions 类中的可移植选项，或者像 OpenAiChatOptions 中那样的模型特定选项。有关模型特定的 ChatOptions 实现的更多信息，请参考 JavaDocs。</p>
<blockquote>
<p>defaultOptions(…): 预设大脑的“运行参数”</p>
<ul>
<li>比喻: 预设机器人的**“思考模式”**。比如，默认是“严谨模式”（temperature&#x3D;0.2）还是“创意模式”（temperature&#x3D;0.8），默认使用哪个型号的大脑（model&#x3D;”gpt-4o”）。</li>
<li>用途: 统一应用的 AI 响应风格，避免在每次调用时都重复设置 temperature, model 等参数。</li>
</ul>
</blockquote>
</li>
<li><p>defaultFunction(String name, String description, java.util.function.Function&lt; I, O &gt; function): name 用于在用户文本中引用该函数。description 解释了函数的目的，帮助 AI 模型选择正确的函数以获得准确响应。function 参数是一个 Java 函数实例，模型会在必要时执行它。</p>
</li>
<li><p>defaultFunctions(String… functionNames): 在应用程序上下文中定义的 java.util.Function 的 bean 名称。</p>
<blockquote>
<p>defaultFunction(…) &#x2F; defaultFunctions(…): 给机器人预装“工具”和“技能”</p>
<ul>
<li>比喻: 给机器人安装一些默认就能使用的工具，比如一个“天气查询器”或者“计算器”。你还要给每个工具一份说明书（description），让机器人知道什么时候该用哪个工具。</li>
<li>用途: 这是实现 Tool Calling &#x2F; Function Calling 的关键。让 AI 能够调用你写的 Java 代码来获取外部信息或执行操作。预设之后，这个机器人就默认拥有了这些超能力。</li>
</ul>
</blockquote>
</li>
<li><p>defaultUser(String text), defaultUser(Resource text), defaultUser(Consumer&lt; UserSpec &gt; userSpecConsumer): 这些方法让您可以定义默认的用户文本。Consumer&lt; UserSpec &gt; 允许您使用 lambda 表达式来指定用户文本和任何默认参数。</p>
<blockquote>
<p>defaultUser(…): 预设一个“开场白”或“默认问题”</p>
<ul>
<li>比喻: 预设机器人每次启动时，默认要处理的第一个任务。</li>
<li>用途: 比较少见，但可能用于某些特定场景。比如，创建一个专门用于“每日新闻总结”的 ChatClient，它的 defaultUser 提示就是“请为我总结今天的头条新闻”。这样调用时甚至连 .user() 都可以省略。</li>
</ul>
</blockquote>
</li>
<li><p>​defaultAdvisors(Advisor… advisor): “顾问”(Advisors) 允许修改用于创建 Prompt 的数据。QuestionAnswerAdvisor 的实现通过将与用户文本相关的上下文信息附加到提示中，来启用检索增强生成（RAG）模式。</p>
</li>
<li><p>defaultAdvisors(Consumer&lt; AdvisorSpec &gt; advisorSpecConsumer): 此方法允许您定义一个 Consumer 来使用 AdvisorSpec 配置多个顾问。顾问可以修改用于创建最终 Prompt 的数据。Consumer&lt; AdvisorSpec &gt; 让您可以指定一个 lambda 来添加顾问，例如 QuestionAnswerAdvisor，它通过根据用户文本将相关上下文信息附加到提示中，来支持检索增强生成。</p>
<blockquote>
<p>defaultAdvisors(…): 给机器人配备一个“外脑”或“研究助理” (RAG 功能)</p>
<ul>
<li>比喻: 这是最强大的配件！你给机器人配备了一个研究团队（Advisor）。当机器人遇到它知识范围外的问题时，这个研究团队（QuestionAnswerAdvisor）会先去你的知识库（向量数据库）里查找相关资料，然后把资料整理好，交给机器人，让它根据这些新资料来回答问题。</li>
<li>用途: 启用 RAG (检索增强生成)。通过预设一个 QuestionAnswerAdvisor，你创建的 ChatClient 就天生具备了结合你私有数据来回答问题的能力。</li>
</ul>
</blockquote>
</li>
</ul>
<p>运行时覆盖默认值</p>
<p>您可以在运行时使用相应的、去掉了 default 前缀的方法来覆盖这些默认值。</p>
<ul>
<li>options(ChatOptions chatOptions)</li>
<li>function(String name, String description, java.util.function.Function&lt; I, O &gt; function)</li>
<li>​functions(String… functionNames)</li>
<li>user(String text), user(Resource text), user(Consumer&lt; UserSpec &gt; userSpecConsumer)</li>
<li>​advisors(Advisor… advisor)</li>
<li>advisors(Consumer&lt; AdvisorSpec &gt; advisorSpecConsumer)</li>
</ul>
<blockquote>
<p><strong>核心原则：default vs. non-default</strong><br>这是最需要记住的一点！</p>
<ul>
<li><p>defaultXxx(…): 在 ChatClient.Builder 上调用，用于配置时设置全局默认值。这是“一次性岗前培训”。</p>
<p>例如：builder.defaultSystem(“你是海盗”)</p>
</li>
<li><p>xxx(…) (没有 default 前缀): 在 chatClient.prompt() 的调用链中调用，用于运行时提供单次调用的特定值。这个特定值会覆盖本次调用的全局默认值。这是“下达临时指令”。</p>
<p>例如：chatClient.prompt().system(“这次别当海盗了，扮演个牛仔”)</p>
</li>
<li><p>这个设计提供了完美的平衡：</p>
<ul>
<li>对于通用行为：在配置中用 defaultXxx() 设置一次，一劳永逸。</li>
<li>对于特殊情况：在运行时用 xxx() 灵活地进行单次覆盖，而不影响全局默认设置。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>总结</strong><br>ChatClient.Builder 不仅仅是一个简单的建造者，它是一个功能丰富的配置中心。通过它的 defaultXxx 系列方法，你可以创建一个高度定制化、功能强大的 ChatClient 实例，它天生就具备：</p>
<ul>
<li>特定的性格 (defaultSystem)</li>
<li>固定的思考模式 (defaultOptions)</li>
<li>强大的外部工具 (defaultFunction)</li>
<li>连接私有知识库的能力 (defaultAdvisors)</li>
</ul>
<p>掌握了这些，你就可以根据不同的业务场景，创建出多个各司其职、高度专业化的“AI 智能助理” Bean，让你的应用架构变得清晰、强大且易于维护。</p>
</blockquote>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">Re-xy</div><div class="post-copyright__author_desc">正在运行...</div></div><div class="post-copyright__post__info"><a class="post-copyright__reprint" title="该文章为转载文章，注意版权协议" href="https://xyre.online/2025/06/16/Spring%20AI/Spring-AI-%E5%8F%82%E8%80%83-%E8%81%8A%E5%A4%A9%E5%AE%A2%E6%88%B7%E7%AB%AFAPI/">转载</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://xyre.online/2025/06/16/Spring%20AI/Spring-AI-%E5%8F%82%E8%80%83-%E8%81%8A%E5%A4%A9%E5%AE%A2%E6%88%B7%E7%AB%AFAPI/')">Spring AI-参考-聊天客户端API</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/img/qrcode-wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/qrcode-wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://xyre.online/2025/06/16/Spring%20AI/Spring-AI-%E5%8F%82%E8%80%83-%E8%81%8A%E5%A4%A9%E5%AE%A2%E6%88%B7%E7%AB%AFAPI/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=undefined&amp;url=https://xyre.online/2025/06/16/Spring%20AI/Spring-AI-%E5%8F%82%E8%80%83-%E8%81%8A%E5%A4%A9%E5%AE%A2%E6%88%B7%E7%AB%AFAPI/&amp;pic=undefined" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本文遵循 CC BY-NC-SA 4.0 许可协议</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Spring-AI-%E5%8F%82%E8%80%83-%E8%81%8A%E5%A4%A9%E5%AE%A2%E6%88%B7%E7%AB%AFAPI/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Spring AI-参考-聊天客户端API<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2025/06/14/Spring%20AI/Spring-AI%E4%B9%8B%E5%BC%80%E5%A7%8B/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring AI之开始</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://twikoo-magic.oss-cn-hangzhou.aliyuncs.com/Tieba-New/image_emoticon95.png" alt="status"/></div></div><div class="author-info__description">Xyre的个人博客</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Xyre</h1><div class="author-info__desc">正在运行...</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/ReappealXy" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/1409387267" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%81%8A%E5%A4%A9%E5%AE%A2%E6%88%B7%E7%AB%AFAPI"><span class="toc-text">聊天客户端API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAChatClient"><span class="toc-text">创建ChatClient</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-ChatClient-Builder"><span class="toc-text">使用自动配置的 ChatClient.Builder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E8%81%8A%E5%A4%A9%E6%A8%A1%E5%9E%8B"><span class="toc-text">使用多个聊天模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E5%8D%95%E4%B8%80%E6%A8%A1%E5%9E%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%9A%E4%B8%AA-ChatClient"><span class="toc-text">针对单一模型类型的多个 ChatClient</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%85%BC%E5%AE%B9-OpenAI-%E7%9A%84-API-%E7%AB%AF%E7%82%B9"><span class="toc-text">多个兼容 OpenAI 的 API 端点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ChatClient-%E6%B5%81%E5%BC%8F-API"><span class="toc-text">ChatClient 流式 API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ChatClient-%E5%93%8D%E5%BA%94-ChatClient-Responses"><span class="toc-text">ChatClient 响应 (ChatClient Responses)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA-ChatResponse"><span class="toc-text">返回一个 ChatResponse</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BD%93-Entity"><span class="toc-text">返回一个实体 (Entity)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F%E5%93%8D%E5%BA%94-Streaming-Responses"><span class="toc-text">流式响应 (Streaming Responses)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA%E6%A8%A1%E6%9D%BF-Prompt-Templates"><span class="toc-text">提示模板 (Prompt Templates)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call-%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC-call-return-values"><span class="toc-text">.call() 的返回值(call() return values)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stream-%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC-stream-return-values"><span class="toc-text">.stream() 的返回值(stream() return values)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Using-Defaults-%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-text">Using Defaults(使用默认值)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%B3%BB%E7%BB%9F%E6%96%87%E6%9C%AC-Default-System-Text"><span class="toc-text">默认系统文本 (Default System Text)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E7%B3%BB%E7%BB%9F%E6%96%87%E6%9C%AC-Default-System-Text-with-parameters"><span class="toc-text">带参数的默认系统文本 (Default System Text with parameters)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%BB%98%E8%AE%A4%E5%80%BC-Other-defaults"><span class="toc-text">其他默认值 (Other defaults)</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/16/Spring%20AI/Spring-AI-%E5%8F%82%E8%80%83-%E8%81%8A%E5%A4%A9%E5%AE%A2%E6%88%B7%E7%AB%AFAPI/" title="Spring AI-参考-聊天客户端API">Spring AI-参考-聊天客户端API</a><time datetime="2025-06-16T01:59:02.000Z" title="发表于 2025-06-16 09:59:02">2025-06-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/14/Spring%20AI/Spring-AI%E4%B9%8B%E5%BC%80%E5%A7%8B/" title="Spring AI之开始">Spring AI之开始</a><time datetime="2025-06-14T06:53:01.000Z" title="发表于 2025-06-14 14:53:01">2025-06-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/30/Spring%20AI/Spring-AI%E4%B9%8B%E6%A6%82%E8%BF%B0-AI%E6%A6%82%E5%BF%B5/" title="Spring AI之概述-AI概念">Spring AI之概述-AI概念</a><time datetime="2025-05-30T13:33:49.000Z" title="发表于 2025-05-30 21:33:49">2025-05-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/29/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%9C%A8%E7%BA%BF%E6%9D%A1%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/" title="在线条码生成工具">在线条码生成工具</a><time datetime="2025-05-29T03:39:15.000Z" title="发表于 2025-05-29 11:39:15">2025-05-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/29/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E7%89%9B%E4%BA%BA%E5%BF%AB%E8%B7%91-%E4%B8%80%E6%AC%BE%E5%BC%80%E6%BA%90%E7%9A%84%E6%B1%82%E8%81%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/" title="牛人快跑 - 一款开源的求职自动化工具">牛人快跑 - 一款开源的求职自动化工具</a><time datetime="2025-05-29T03:36:55.000Z" title="发表于 2025-05-29 11:36:55">2025-05-29</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By Xyre</div><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Rexy%20%E4%B8%8D%E6%83%B3%E4%B8%8A%E7%8F%AD--xy%20" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div><div class="footer_custom_text">© 2025 Re-xy. All rights reserved.</div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a></p></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI-Song-Maker-%E5%9C%A8%E7%BA%BFAI%E6%AD%8C%E6%9B%B2%E7%94%9F%E6%88%90%E5%99%A8/" style="font-size: 0.88rem;">AI Song Maker-在线AI歌曲生成器<sup>1</sup></a><a href="/tags/CSDN%E6%96%87%E7%AB%A0%E8%A7%A3%E9%94%81%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">CSDN文章解锁工具<sup>1</sup></a><a href="/tags/Char%E5%92%8CCharacter/" style="font-size: 0.88rem;">Char和Character<sup>1</sup></a><a href="/tags/Chrome%E4%B8%80%E9%94%AE%E8%A7%A3%E9%99%A4%E5%A4%8D%E5%88%B6/" style="font-size: 0.88rem;">Chrome一键解除复制<sup>1</sup></a><a href="/tags/ComicBrief-AI%E6%BC%AB%E7%94%BB%E7%94%9F%E6%88%90%E5%99%A8/" style="font-size: 0.88rem;">ComicBrief-AI漫画生成器<sup>1</sup></a><a href="/tags/DeepWiki-github%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6/" style="font-size: 0.88rem;">DeepWiki-github百科全书<sup>1</sup></a><a href="/tags/Deskreen-%E7%94%B5%E8%84%91%E6%97%A0%E7%BA%BF%E5%89%AF%E5%B1%8F%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">Deskreen-电脑无线副屏工具<sup>1</sup></a><a href="/tags/Excel%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%86%99/" style="font-size: 0.88rem;">Excel自动填写<sup>1</sup></a><a href="/tags/FastFind-%E5%85%A8%E7%9B%98%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E8%BD%AF%E4%BB%B6/" style="font-size: 0.88rem;">FastFind-全盘文件搜索软件<sup>1</sup></a><a href="/tags/Get-Z-Library/" style="font-size: 0.88rem;">Get Z-Library<sup>1</sup></a><a href="/tags/HTTP/" style="font-size: 0.88rem;">HTTP<sup>1</sup></a><a href="/tags/Hexo/" style="font-size: 0.88rem;">Hexo<sup>1</sup></a><a href="/tags/InputTip-%E4%B8%80%E4%B8%AA%E5%AE%9E%E6%97%B6%E7%9A%84%E8%BE%93%E5%85%A5%E6%B3%95%E7%8A%B6%E6%80%81%E6%8F%90%E7%A4%BA%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">InputTip-一个实时的输入法状态提示工具<sup>1</sup></a><a href="/tags/Integer%E5%92%8Cint/" style="font-size: 0.88rem;">Integer和int<sup>1</sup></a><a href="/tags/JDBC/" style="font-size: 0.88rem;">JDBC<sup>2</sup></a><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>1</sup></a><a href="/tags/Java%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 0.88rem;">Java面试题<sup>1</sup></a><a href="/tags/Mindows-%E7%BB%99%E4%BD%A0%E7%9A%84Android%E5%88%B7%E4%B8%8AWindows/" style="font-size: 0.88rem;">Mindows-给你的Android刷上Windows<sup>1</sup></a><a href="/tags/MyPublicWiFi-%E2%80%93-%E5%8A%9F%E8%83%BD%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%97%A0%E7%BA%BF%E7%83%AD%E7%82%B9%E5%85%B1%E4%BA%AB%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">MyPublicWiFi – 功能强大的无线热点共享工具<sup>1</sup></a><a href="/tags/NovaAI%E5%B7%A5%E5%85%B7%E7%AE%B1/" style="font-size: 0.88rem;">NovaAI工具箱<sup>1</sup></a><a href="/tags/PortableApps%EF%BC%88%E4%BE%BF%E6%90%BA%E5%BC%8F%E5%BA%94%E7%94%A8%EF%BC%89%E4%B8%80%E4%B8%AA%E5%85%8D%E8%B4%B9%E7%9A%84%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%AB%99/" style="font-size: 0.88rem;">PortableApps（便携式应用）一个免费的软件下载网站<sup>1</sup></a><a href="/tags/Servlet/" style="font-size: 0.88rem;">Servlet<sup>1</sup></a><a href="/tags/Spring-AI-%E5%8F%82%E8%80%83-%E8%81%8A%E5%A4%A9%E5%AE%A2%E6%88%B7%E7%AB%AFAPI/" style="font-size: 0.88rem;">Spring AI-参考-聊天客户端API<sup>1</sup></a><a href="/tags/Spring-AI%E4%B9%8B%E5%BC%80%E5%A7%8B/" style="font-size: 0.88rem;">Spring AI之开始<sup>1</sup></a><a href="/tags/Spring-AI%E4%B9%8B%E6%A6%82%E8%BF%B0-AI%E6%A6%82%E5%BF%B5/" style="font-size: 0.88rem;">Spring AI之概述-AI概念<sup>1</sup></a><a href="/tags/TrimSpace-%E5%85%8D%E8%B4%B9%E5%9C%A8%E7%BA%BF%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">TrimSpace-免费在线图片处理工具<sup>1</sup></a><a href="/tags/ZIPCracker-%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%96%87%E4%BB%B6%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">ZIPCracker-强大的文件密码破解工具<sup>1</sup></a><a href="/tags/animefeet/" style="font-size: 0.88rem;">animefeet<sup>1</sup></a><a href="/tags/leetcode/" style="font-size: 0.88rem;">leetcode<sup>24</sup></a><a href="/tags/remove-photos/" style="font-size: 0.88rem;">remove.photos<sup>1</sup></a><a href="/tags/win%E7%B3%BB%E7%BB%9F%E6%A1%8C%E9%9D%A2%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">win系统桌面管理工具<sup>1</sup></a><a href="/tags/zPaste-Windows%E5%89%AA%E5%88%87%E6%9D%BF%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">zPaste-Windows剪切板管理工具<sup>1</sup></a><a href="/tags/%E4%B8%80%E9%94%AE%E6%BF%80%E6%B4%BB-JetBrains-%E5%85%A8%E5%AE%B6%E6%A1%B6/" style="font-size: 0.88rem;">一键激活 JetBrains 全家桶<sup>1</sup></a><a href="/tags/%E4%B8%8A%E7%8F%AD%E7%9C%8B%E5%B0%8F%E8%AF%B4%E9%98%85%E8%AF%BB%E5%99%A8-%E9%9A%90%E8%94%BD%E5%BC%8F%E5%B0%8F%E8%AF%B4%E9%98%85%E8%AF%BB%E5%99%A8/" style="font-size: 0.88rem;">上班看小说阅读器-隐蔽式小说阅读器<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E7%BE%8E%E5%8C%96/" style="font-size: 0.88rem;">代码美化<sup>1</sup></a><a href="/tags/%E5%9C%A8%E7%BA%BF%E6%9D%A1%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">在线条码生成工具<sup>1</sup></a><a href="/tags/%E5%9C%A8%E7%BA%BF%E7%94%B5%E5%AD%90%E4%B9%A6%E9%98%85%E8%AF%BB/" style="font-size: 0.88rem;">在线电子书阅读<sup>1</sup></a><a href="/tags/%E5%AE%9E%E6%97%B6%E5%B7%A5%E8%B5%84%E8%AE%A1%E7%AE%97%E5%99%A8/" style="font-size: 0.88rem;">实时工资计算器<sup>1</sup></a><a href="/tags/%E7%A4%BA%E4%BE%8B/" style="font-size: 0.88rem;">示例<sup>1</sup></a><a href="/tags/%E8%B7%AF%E5%BE%84%E5%A4%84%E7%90%86/" style="font-size: 0.88rem;">路径处理<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("03/11/2025 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2025 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Xyre 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("03/11/2025 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://img.shields.io/badge/Rexy%20%E4%B8%8D%E6%83%B3%E4%B8%8A%E7%8F%AD--xy%20";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'your-env-id',
      region: 'ap-shanghai',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'your-env-id',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'your-env-id',
        region: 'ap-shanghai',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>